#  深入C库函数

## C标准

C 标准主要由两部分组成，一部分描述**C的语法**，另一部分描述**C标准库**（描述了一些C标准函数的原型，但是不提供实现）。
C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。

常见的C标准就是ANSI C；美国国家标准协会；
为了提高C语言的开发效率，C标准定义了一系列常用的函数，称为**C标准库函数**。
应用程序开发者可以包含这些标准函数的头文件，来调用这些C标准函数，来开发应用，这样就可以屏蔽平台的差异；



## ANSI C标准

ANSI C是由美国国家标准协会（ANSI）及国际标准化组织（ISO）推出的关于C语言的标准。ANSI C 主要标准化了现存的实现， 同时增加了一些来自 C++ 的内容 （主要是函数原型） 并支持多国字符集 （包括备受争议的三字符序列）。 ANSI C 标准同时规定了 C 运行期库例程的标准。

C 的第一个标准是由ANSI发布的。虽然这份文档后来被国际标准化组织(ISO)采纳并且ISO发布的修订版也被ANSI采纳了，但名称ANSI C(而不是 ISO C)仍被广泛使用。一些软件开发者使用ISO C，还有一些使用 Standard C。
C89
1983年，美国国家标准协会组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，并在作为ANSI X3.159-1989 "Programming Language C"正式生效。这个版本的语言经常被称作"ANSI C"，或有时称为"C89"（为了区别C99）。
C90
在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会采纳为ISO/IEC 9899:1990。这个版本有时候称为C90。因此，C89和C90通常指同一种语言。
C99
在2000年三月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。
C11
在2011年12月，ANSI采纳了ISO/IEC 9899:2011标准。这个标准通常即C11，它是C程序语言的现行标准。

1995年，Normative Addendum 1 (NA1)批准了3个头文件(iso646.h, wchar.h, and wctype.h)增加到C标准函数库中。C99标准增加了6个头文件(complex.h, fenv.h, inttypes.h, stdbool.h, stdint.h, and tgmath.h)。C11标准中又新增了5个头文件(stdalign.h, stdatomic.h, stdnoreturn.h, threads.h, and uchar.h)。至此，C标准函数库共29个头文件


| 头文件                | 简介                                             |
| --------------------- | ------------------------------------------------ |
| <assert.h>            | 条件编译宏，将参数与零比较                       |
| <ctype.h>             | 用来确定包含于字符数据中的类型的函数             |
| <errno.h>             | 报告错误条件的宏                                 |
| <float.h>             | 浮点数类型的极限                                 |
| <limits.h>            | 基本类型的大小                                   |
| <locale.h>            | 本地化工具                                       |
| <math.h>              | 常用数学函数                                     |
| <setjmp.h>            | 非局部跳转                                       |
| <signal.h>            | 信号处理                                         |
| <stdarg.h>            | 可变参数                                         |
| <stddef.h>            | 常用宏定义                                       |
| <stdio.h>             | 输入/输出                                        |
| <stdlib.h>            | 基础工具：内存管理、程序工具、字符串转换、随机数 |
| <string.h>            | 字符串处理                                       |
| <time.h>              | 时间/日期工具                                    |
| <iso646.h> (C95)      | 符号的替代写法                                   |
| <wchar.h> (C95)       | 扩展多字节和宽字符工具                           |
| <wctype.h> (C95)      | 用来确定包含于宽字符数据中的类型的函数           |
| <complex.h> (C99)     | 复数运算                                         |
| <fenv.h> (C99)        | 浮点数环境                                       |
| <inttypes.h> (C99)    | 整数类型的格式转换                               |
| <stdbool.h> (C99)     | 布尔类型                                         |
| <stdint.h> (C99)      | 定宽整数类型                                     |
| <tgmath.h> (C99)      | 泛型数学（包装 math.h 和 complex.h 的宏）        |
| <stdalign.h> (C11)    | alignas 与 alignof 便利宏                        |
| <stdatomic.h> (C11)   | 原子类型                                         |
| <stdnoreturn.h> (C11) | noreturn 便利宏                                  |
| <threads.h> (C11)     | 线程库                                           |
| <uchar.h> (C11)       | UTF-16 和 UTF-32 字符工具                        |

说明：

- C89 定义15个标准头文件
- C95 新增定义3个标准头文件
- C99 新增定义6个标准头文件
- C11 新增定义5个标准头文件

编译器支持：

- GCC 3.0 开始支持 C99 标准
- GCC 4.6 开始支持 C11 标准



## C运行库

C标准库函数的实现留给了各个系统平台；
这个实现就是**C运行时库(C Run Time Libray) ，简称CRT**；
C运行库，是和平台相关的，即和操作系统相关的；
C运行库（CRT）从某种程度上来讲是**C语言的程序和不同操作系统平台之间的抽象层**;//接口是统一的标准，实现由各个平台自己实现；

**Linux和Windows平台下的两个主要C语言运行库分别为**
**glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time）。**

值得注意的是，像线程操作这样的功能并不是标准的C语言运行库的一部分，
但是glibc和MSVCRT都包含了线程操作的库函数。所以glibc和MSVCRT事实上是标准C语言运行库的超集，
它们各自对C标准库进行了一些扩展。
也就是说CRT实际上包含两部分，一部分实现是**基于C标准库**来的，一部分实现是**根据平台自身开发的库**；
某种程度上是**C运行库是C标准库的一个扩展库**，加了很多C标准库所没有的与平台相关的或者不相关的库接口函数。


要在一个平台上支持C语言，不仅要实现符合平台的C编译器，还要实现C标准库，这样的实现才算符合C标准。



## linux下的C运行库 —— glibc和libc

glibc和libc都是Linux下的C函数库，那么到底有什么区别呢？

libc是Linux下的ANSI C的函数库；

glibc是Linux下的GUN C函数库；

libc是Linux原来的标准C库。而glibc(GUN C Library)后来取代了libc。

ANSI C和GNU C有什么区别呢？

ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。

这个库可以根据 头文件划分为 15 个部分，其中包括：（C89标准）
字符类型 (ctype.h)、
错误码 (errno.h)、 
浮点常数 (float.h)、
数学函数 (math.h)、
数学常数 (limits.h)、
标准定义 (stddef.h)、 
标准 I/O (stdio.h)、
工具函数 (stdlib.h)、
字符串操作 (string.h)、 
时间和日期 (time.h)、
可变参数表 (stdarg.h)、
信号 (signal.h)、 
非局部跳转 (setjmp.h)、
本地信息 (locale.h)、
程序断言 (assert.h) 
等等。这在其他的C语言的IDE中都是有的。

而GNU C函数库是一种类似于第三方插件的东西，由于Linux是用Ｃ语言写的，所以Linux的一些操作是用C语言实现的，所以GNU组织开发了一个C语言的库用于我们更好的利用C语言开发基于Linux操作系统的程序。其实我们可以把它理解为类似于Qt是一个C++的第三方函数库一样。

不过现在的不同的Linux的发行版本对这两个函数库有不同的处理方法，有的可能已经集成在同一个库里了，例如Ubuntu就只有glibc。



## GNU

GNU是一个自由的操作系统，也是一个自由的软件运动项目，也是一些开源软件的标签。

到上世纪90 年代初，GNU 项目已经开发出许多高质量的免费软件，其中包括有名的emacs 编辑系统、bash shell 程序、gcc 系列编译程序、gdb 调试程序等等。这些软件为Linux 操作系统的开发创造了一个合适的环境，是Linux 能够诞生的基础之一。以至于目前许多人都将Linux 操作系统称为"GNU/Linux"操作系统。

GNU软件组包括了一系列的自由软件，建立了一个自由的软件联盟，提供了一系列的软件包。很多类Unix操作系统都可以使用GNU的软件包。

GNU软件包列表：

该系统的基本组成包括GNU编译器套装（GCC）、GNU的C库（glibc）、以及GNU核心工具组（coreutils），另外也是GNU除错器（GDB）、GNU二进制实用程序（binutils）的GNU Cashshell中和GNOME桌面环境。GNU开发人员已经向GNU应用程序和工具的Linux移植，也广泛应用在其它操作系统中使用，如BSD变体的Solaris，和OS X作出了贡献。



### coreutils 与 util-linux

许多 Linux 系统管理员最基本和常用的工具主要包括在两套实用程序中：GNU 核心实用程序（coreutils）和 util-linux。它们的基本功能允许系统管理员执行许多管理 Linux 系统的任务，包括管理和操作文本文件、目录、数据流、存储介质、进程控制、文件系统等等。

这些工具是不可缺少的，因为没有它们，就不可能在 Unix 或 Linux 计算机上完成任何有用的工作。

（info coreutils）

```
* Output of entire files::       cat tac nl od base32 base64
* Formatting file contents::     fmt pr fold
* Output of parts of files::     head tail split csplit
* Summarizing files::            wc sum cksum b2sum md5sum sha1sum sha2
* Operating on sorted files::    sort shuf uniq comm ptx tsort
* Operating on fields::          cut paste join
* Operating on characters::      tr expand unexpand
* Directory listing::            ls dir vdir dircolors
* Basic operations::             cp dd install mv rm shred
* Special file types::           mkdir rmdir unlink mkfifo mknod ln link readlink
* Changing file attributes::     chgrp chmod chown touch
* Disk usage::                   df du stat sync truncate
* Printing text::                echo printf yes
* Conditions::                   false true test expr
* Redirection::                  tee
* File name manipulation::       dirname basename pathchk mktemp realpath
* Working context::              pwd stty printenv tty
* User information::             id logname whoami groups users who
* System context::               date arch nproc uname hostname hostid uptime
* SELinux context::              chcon runcon
* Modified command invocation::  chroot env nice nohup stdbuf timeout
* Process control::              kill
* Delaying::                     sleep
* Numeric operations::           factor numfmt seq
```



这个列表里有 102 个实用程序。它涵盖了在 Unix 或 Linux 主机上执行基本任务所需的许多功能。但是，很多基本的实用程序都缺失了，例如，mount 和 umount 命令不在这个列表中。这些命令和其他许多不在 GNU 核心实用程序中的命令可以在 util-linux 中找到。




util-linix 实用程序包中包含了许多系统管理员常用的其它命令。这些实用程序是由 Linux 内核组织发布的，这 107 条命令中几乎每一个都来自原本是三个单独的集合 —— fileutils、shellutils 和 textutils，2003 年它们被合并成一个包：util-linux。

```
agetty          fsck.minix      mkfs.bfs        setpriv 
blkdiscard      fsfreeze        mkfs.cramfs     setsid 
blkid           fstab           mkfs.minix      setterm
blockdev        fstrim          mkswap          sfdisk
cal             getopt          more            su 
cfdisk          hexdump         mount           sulogin
chcpu           hwclock         mountpoint      swaplabel
chfn            ionice          namei           swapoff 
chrt            ipcmk           newgrp          swapon 
chsh            ipcrm           nologin         switch_root
colcrt          ipcs            nsenter         tailf
col             isosize         partx           taskset
colrm           kill            pg              tunelp
column          last            pivot_root      ul
ctrlaltdel      ldattach        prlimit         umount 
ddpart          line            raw             unshare
delpart         logger          readprofile     utmpdump
dmesg           login           rename          uuidd
eject           look            renice          uuidgen
fallocate       losetup         reset           vipw
fdformat        lsblk           resizepart      wall 
fdisk           lscpu           rev             wdctl
findfs          lslocks         RTC Alarm       whereis 
findmnt         lslogins        runuser         wipefs
flock           mcookie         script          write 
fsck            mesg            scriptreplay    zramctl
fsck.cramfs     mkfs            setarch
```



## glibc

stdc 是一个语言的标准，glibc 是在 stdc 基础上扩展的某一个标准。
标准库一般是针对特定编译器而言的，也就是这个编译器缺省提供的库。对 gnu c 来说，自然这个标准库就是 glibc 库。每个编译器提供的标准库可能不同。但他们可能都包含 stdc 这个子集。

在Linux平台上**最广泛使用的C运行库是glibc**，其中包括C标准库的实现，也包括所有系统函数。
几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。
GNU C：GNU C实际上是GNU C库，又称为glibc，即c运行库； 

glibc是linux下面c标准库的实现，即GNU C Library。glibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准c库，而Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc（https://www.uclibc.org/）、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。

glibc是gnu发布的libc库，也即c运行库。glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现（还有一些系统调用），主要的如下：
（1）string，字符串处理
（2）signal，信号处理
（3）dlfcn，管理共享库的动态加载
（4）direct，文件目录操作
（5）elf，共享库的动态加载器，也即interpreter
（6）iconv，不同字符集的编码转换
（7）inet，socket接口的实现
（8）intl，国际化，也即gettext的实现
（9）io
（10）linuxthreads
（11）locale，本地化
（12）login，虚拟终端设备的管理，及系统的安全访问
（13）malloc，动态内存的分配与管理
（14）nis
（15）stdlib，其它基本功能

GlibC

http://www.gnu.org/software/libc/libc.html

https://sourceware.org/git/glibc.git

http://ftp.gnu.org/gnu/glibc/


最基本、最常用的**C标准库函数和系统函数**在**libc.so**库文件中，几乎所有C程序的运行都依赖于libc.so
有些做数学计算的C程序依赖于**libm.so**，
多线程的C程序依赖于**libpthread.so**。
libc有时时专指libc.so这个库文件，而说glibc时指的是**glibc提供的所有库文件**。 

值得注意的是，像**线程操作这样的功能并不是C标准库的一部分（也就是说C标准没有定义线程操作相关的函数原型）**；
但是glibc和MSVCRT（**Windows系统下的C运行库**）都包含了线程操作的库函数。
比如glibc有一个可选的**pthread库**中的pthread_create()函数可以用来创建线程;
而MSVCRT中可以使用_beginthread()函数来创建线程。
所以glibc和MSVCRT事实上是**标准C语言运行库的超集**，**它们各自对C标准库进行了一些扩展**。 

glibc的发布版本主要由两部分组成，一部分是**头文件**，比如stdio.h、stdlib.h等，它们往往位于/usr/include;
另外一部分则是**库的二进制文件部分**。二进制部分主要的就是C语言标准库，它有静态和动态两个版本。
动态的标准库我们及在本书的前面章节中碰到过了，它位于/lib/libc.so.6;而静态标准库位于/usr/lib/libc.a。

事实上glibc除了C标准库之外，还有几个辅助程序运行的运行库，这几个文件可以称得上是真正的“运行库”。
它们就是/usr/lib/crt1.o、/usr/lib/crti.o和/usr/lib/crtn.o。 

比如我们可以在不同的操作系统平台下使用fread来读取文件，
而事实上fread在不同的操作系统平台下的实现是不同的，
但作为运行库的使用者我们不需要关心这一点。
虽然各个平台下的C语言运行库提供了很多功能，但很多时候它们毕竟有限，
比如用户的权限控制、操作系统线程创建等都不是属于标准的C语言运行库。
于是我们不得不通过其他的办法，诸如绕过C语言运行库直接调用操作系统API或使用其他的库。



https://www.cnblogs.com/grooovvve/p/12907659.html



glibc头文件介绍
https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html



glibc官方手册

http://www.gnu.org/software/libc/manual/html_mono/libc.html



### 系统调用和标准C函数库

1.系统调用是为了方便应用使用操作系统的接口，而库函数是为了方便人们编写应用程序而引出的，比如你自己编写一个
函数其实也可以说就是一个库函数。

2.系统调用可以理解为内核提供给我们在用户态用的接口函数，可以认为是某种内核的库函数。

3.read就是系统调用,而fread就是标准C库函数.

4.很多c函数库中的函数名与系统调用的名称一样是因为该函数本身其实就是调用系统调用，放到c函数库就是为了用户态的使用

5.写程序直接使用的是库函数，而库函数内部可能就是调用的同名系统调用





## GCC

GCC原名GNU C Compiler，后来逐渐支持更多的语言编译（C++、Fortran、Pascal、Objective-C、Java、Ada、Go等），所以变成了GNU Compiler Collection（GNU编译器套装）。

gcc 是编译器，基本上 Linux 下所有的程序（包括内核）都是 gcc 编译的，libc 当然也是。
gcc 和 libc 是互相依赖的两个软件，它们合作的方式类似 Linux 系统的 "自举"。先在一个可以运行的带有老 libc 和 gcc 的系统上，用老 gcc 编译出一个新版本的 gcc + 老 libc，再用这个新 gcc 编译出一个新 gcc + 新 libc，再用这套东东编译整个新系统。

GCC
https://gcc.gnu.org/
https://gcc.gnu.org/git/gcc.git

GCC中常见预定义宏
在标准C以及各中编译器中定义了一些对象宏, 这些宏的名称以"__"开头和结尾, 并且都是大写字符. 这些预定义宏可以被#undef, 也可以被重定义。

在ANSI C标准中定义了__FILE__，__LINE__，__DATA__,__TIME__,__STDC__等标准的预定义宏。GCC对其进行扩展，也定义了多个预定义宏。
概括起来GCC中可使用的预定义宏涵盖了如下几方面的信息：
1、宿主的信息：GNU的版本，编译器的版本，类型的相关信息，字节序信息等。__GNUC__、__GNUC_MINOR__、__GNUC_PATCHLEVEL__、__VERSION__
2、编译动作的信息：编译的日期、时间；编译时是否进行了时间或空间上的优化；定义的inline是否被编译器执行等。__DATE__,__TIME__，__TIMESTAMP__
3、文件的信息：文件名称、函数名称、行数信息、文件最后修改时间等等。__FILE__  __FUNCTION__  __LINE__  __BASE_FILE__
4、计数信息：__COUNTER__,__INCLUDE_LEVEL__等。

__FUNCTION__       所在函数的函数名称    （字符串）
 __LINE__          所在行的行号          （数字）
 __FILE__          所在文件名称          （字符串） 
__DATE__           编译的时的日期        （字符串，例如"Nov 29 2012")
__TIME__           编译时的时间           (字符串，例如"15:05:25"）


Gcc高级用法

1、查看Gcc中的预定义宏
cpp -dM /dev/null
gcc -E -dM bl.c


2、查看编译器默认的查找头文件与库的路径
echo 'main(){}'|arm-linux-gcc -E -v -

1.include<头文件名>和include"头文件名"
如：include<stdio.h>和include"stdio.h"
前者（使用<>），来引用stdio.h文件，是首先检索标准路径，看看这些文件夹下是否有该头文件；如果没有，也不会检索当前文件所在路径，并将报错。
后者（使用""），来引用stdio.h文件，是首先检索文件的当前路径；如果没有，再检索标准路径，看看这些文件夹下是否有该头文件。
2.linux下，上述标准路径有：/usr/include，/usr/local/include。
3.<sys/头文件名>。如<sys/io.h>，<net/ethernet.h>等。其中，前面的字符串（如sys,net）表示标准路径下的文件夹名，后面的字符串（如io.h,ethernet.h），表示在linux标准路径下的各文件夹下的头文件名，如sys文件夹下的io.h文件，即我们可以在/usr/include/sys目录下发现io.h文件。
4.如果想在指定路径下检索头文件，可加选项-I。如我的/home/Desktop目录下有个头文件local1.h，在编译包含local1.h的test.c文件时，可用：gcc test.c -o test -I /root/Desktop。 

3、SPECs文件修改与使用

4、如果编译的时候加入了-nostdinc，则不会到默认路径下去搜索。比如用GCC编译器编译一个新的linux内核。


小代码
#include <stdio.h>

int main () {
	char * p;
	
	FILE *file;
    char line[300];
	//popen("cpp -dM /dev/null", "r");
    file = popen("echo 'main(){}'|gcc -E -v -", "r");
    if (NULL != file)
    {
        while (fgets(line, 300, file) != NULL)
        {
            printf("line=%s\n", line);
        }
    }
    else
    {
        return 1;
    }
    pclose(file);
	
	
	
	printf("hello https://tool.lu/  %d %d\n", sizeof(char *),sizeof(int *));
	return 0;
}



### binutils

binutils提供了一系列用来创建、管理和维护二进制目标文件的工具程序，如汇编（as）、连接（ld）、静态库归档（ar）、反汇编 （objdump）、elf结构分析工具（readelf）、无效调试信息和符号的工具（strip）等。通常，binutils与gcc是紧密相集成 的，没有binutils的话，gcc是不能正常工作的。




glibc

[root@localhost home]# rpm -ql glibc-headers
/usr/include/_G_config.h
/usr/include/a.out.h
/usr/include/aio.h
/usr/include/aliases.h
/usr/include/alloca.h
/usr/include/ar.h
/usr/include/argp.h
/usr/include/argz.h
/usr/include/arpa
/usr/include/arpa/ftp.h
/usr/include/arpa/inet.h
/usr/include/arpa/nameser.h
/usr/include/arpa/nameser_compat.h
/usr/include/arpa/telnet.h
/usr/include/arpa/tftp.h
/usr/include/assert.h
/usr/include/bits
/usr/include/bits/a.out.h
/usr/include/bits/byteswap-16.h
/usr/include/bits/byteswap.h
/usr/include/bits/cmathcalls.h
/usr/include/bits/confname.h
/usr/include/bits/dirent.h
/usr/include/bits/dlfcn.h
/usr/include/bits/elfclass.h
/usr/include/bits/endian.h
/usr/include/bits/environments.h
/usr/include/bits/epoll.h
/usr/include/bits/errno.h
/usr/include/bits/error.h
/usr/include/bits/eventfd.h
/usr/include/bits/fcntl-linux.h
/usr/include/bits/fcntl.h
/usr/include/bits/fcntl2.h
/usr/include/bits/fenv.h
/usr/include/bits/fenvinline.h
/usr/include/bits/huge_val.h
/usr/include/bits/huge_valf.h
/usr/include/bits/huge_vall.h
/usr/include/bits/hwcap.h
/usr/include/bits/in.h
/usr/include/bits/inf.h
/usr/include/bits/initspin.h
/usr/include/bits/inotify.h
/usr/include/bits/ioctl-types.h
/usr/include/bits/ioctls.h
/usr/include/bits/ipc.h
/usr/include/bits/ipctypes.h
/usr/include/bits/libc-lock.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/link.h
/usr/include/bits/local_lim.h
/usr/include/bits/locale.h
/usr/include/bits/math-finite.h
/usr/include/bits/mathcalls.h
/usr/include/bits/mathdef.h
/usr/include/bits/mathinline.h
/usr/include/bits/mman.h
/usr/include/bits/monetary-ldbl.h
/usr/include/bits/mqueue.h
/usr/include/bits/mqueue2.h
/usr/include/bits/msq.h
/usr/include/bits/nan.h
/usr/include/bits/netdb.h
/usr/include/bits/param.h
/usr/include/bits/poll.h
/usr/include/bits/poll2.h
/usr/include/bits/posix1_lim.h
/usr/include/bits/posix2_lim.h
/usr/include/bits/posix_opt.h
/usr/include/bits/printf-ldbl.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/resource.h
/usr/include/bits/sched.h
/usr/include/bits/select.h
/usr/include/bits/select2.h
/usr/include/bits/sem.h
/usr/include/bits/semaphore.h
/usr/include/bits/setjmp.h
/usr/include/bits/setjmp2.h
/usr/include/bits/shm.h
/usr/include/bits/sigaction.h
/usr/include/bits/sigcontext.h
/usr/include/bits/siginfo.h
/usr/include/bits/signalfd.h
/usr/include/bits/signum.h
/usr/include/bits/sigset.h
/usr/include/bits/sigstack.h
/usr/include/bits/sigthread.h
/usr/include/bits/sockaddr.h
/usr/include/bits/socket.h
/usr/include/bits/socket2.h
/usr/include/bits/socket_type.h
/usr/include/bits/stab.def
/usr/include/bits/stat.h
/usr/include/bits/statfs.h
/usr/include/bits/statvfs.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-float.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/string.h
/usr/include/bits/string2.h
/usr/include/bits/string3.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/syscall.h
/usr/include/bits/sysctl.h
/usr/include/bits/syslog-ldbl.h
/usr/include/bits/syslog-path.h
/usr/include/bits/syslog.h
/usr/include/bits/termios.h
/usr/include/bits/time.h
/usr/include/bits/timerfd.h
/usr/include/bits/timex.h
/usr/include/bits/types.h
/usr/include/bits/typesizes.h
/usr/include/bits/uio.h
/usr/include/bits/unistd.h
/usr/include/bits/ustat.h
/usr/include/bits/utmp.h
/usr/include/bits/utmpx.h
/usr/include/bits/utsname.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar.h
/usr/include/bits/wchar2.h
/usr/include/bits/wordsize.h
/usr/include/bits/xopen_lim.h
/usr/include/byteswap.h
/usr/include/complex.h
/usr/include/cpio.h
/usr/include/crypt.h
/usr/include/ctype.h
/usr/include/dirent.h
/usr/include/dlfcn.h
/usr/include/elf.h
/usr/include/endian.h
/usr/include/envz.h
/usr/include/err.h
/usr/include/errno.h
/usr/include/error.h
/usr/include/execinfo.h
/usr/include/fcntl.h
/usr/include/features.h
/usr/include/fenv.h
/usr/include/fmtmsg.h
/usr/include/fnmatch.h
/usr/include/fpu_control.h
/usr/include/fstab.h
/usr/include/fts.h
/usr/include/ftw.h
/usr/include/gconv.h
/usr/include/getopt.h
/usr/include/glob.h
/usr/include/gnu
/usr/include/gnu-versions.h
/usr/include/gnu/lib-names.h
/usr/include/gnu/libc-version.h
/usr/include/gnu/stubs.h
/usr/include/grp.h
/usr/include/gshadow.h
/usr/include/iconv.h
/usr/include/ieee754.h
/usr/include/ifaddrs.h
/usr/include/inttypes.h
/usr/include/langinfo.h
/usr/include/lastlog.h
/usr/include/libgen.h
/usr/include/libintl.h
/usr/include/libio.h
/usr/include/limits.h
/usr/include/link.h
/usr/include/locale.h
/usr/include/malloc.h
/usr/include/math.h
/usr/include/mcheck.h
/usr/include/memory.h
/usr/include/mntent.h
/usr/include/monetary.h
/usr/include/mqueue.h
/usr/include/net
/usr/include/net/ethernet.h
/usr/include/net/if.h
/usr/include/net/if_arp.h
/usr/include/net/if_packet.h
/usr/include/net/if_ppp.h
/usr/include/net/if_shaper.h
/usr/include/net/if_slip.h
/usr/include/net/ppp-comp.h
/usr/include/net/ppp_defs.h
/usr/include/net/route.h
/usr/include/netash
/usr/include/netash/ash.h
/usr/include/netatalk
/usr/include/netatalk/at.h
/usr/include/netax25
/usr/include/netax25/ax25.h
/usr/include/netdb.h
/usr/include/neteconet
/usr/include/neteconet/ec.h
/usr/include/netinet
/usr/include/netinet/ether.h
/usr/include/netinet/icmp6.h
/usr/include/netinet/if_ether.h
/usr/include/netinet/if_fddi.h
/usr/include/netinet/if_tr.h
/usr/include/netinet/igmp.h
/usr/include/netinet/in.h
/usr/include/netinet/in_systm.h
/usr/include/netinet/ip.h
/usr/include/netinet/ip6.h
/usr/include/netinet/ip_icmp.h
/usr/include/netinet/tcp.h
/usr/include/netinet/udp.h
/usr/include/netipx
/usr/include/netipx/ipx.h
/usr/include/netiucv
/usr/include/netiucv/iucv.h
/usr/include/netpacket
/usr/include/netpacket/packet.h
/usr/include/netrom
/usr/include/netrom/netrom.h
/usr/include/netrose
/usr/include/netrose/rose.h
/usr/include/nfs
/usr/include/nfs/nfs.h
/usr/include/nl_types.h
/usr/include/nss.h
/usr/include/obstack.h
/usr/include/paths.h
/usr/include/poll.h
/usr/include/printf.h
/usr/include/protocols
/usr/include/protocols/routed.h
/usr/include/protocols/rwhod.h
/usr/include/protocols/talkd.h
/usr/include/protocols/timed.h
/usr/include/pthread.h
/usr/include/pty.h
/usr/include/pwd.h
/usr/include/re_comp.h
/usr/include/regex.h
/usr/include/regexp.h
/usr/include/resolv.h
/usr/include/rpc
/usr/include/rpc/auth.h
/usr/include/rpc/auth_des.h
/usr/include/rpc/auth_unix.h
/usr/include/rpc/clnt.h
/usr/include/rpc/des_crypt.h
/usr/include/rpc/key_prot.h
/usr/include/rpc/netdb.h
/usr/include/rpc/pmap_clnt.h
/usr/include/rpc/pmap_prot.h
/usr/include/rpc/pmap_rmt.h
/usr/include/rpc/rpc.h
/usr/include/rpc/rpc_des.h
/usr/include/rpc/rpc_msg.h
/usr/include/rpc/svc.h
/usr/include/rpc/svc_auth.h
/usr/include/rpc/types.h
/usr/include/rpc/xdr.h
/usr/include/rpcsvc
/usr/include/rpcsvc/bootparam.h
/usr/include/rpcsvc/bootparam_prot.h
/usr/include/rpcsvc/bootparam_prot.x
/usr/include/rpcsvc/key_prot.h
/usr/include/rpcsvc/key_prot.x
/usr/include/rpcsvc/klm_prot.h
/usr/include/rpcsvc/klm_prot.x
/usr/include/rpcsvc/mount.h
/usr/include/rpcsvc/mount.x
/usr/include/rpcsvc/nfs_prot.h
/usr/include/rpcsvc/nfs_prot.x
/usr/include/rpcsvc/nis.h
/usr/include/rpcsvc/nis.x
/usr/include/rpcsvc/nis_callback.h
/usr/include/rpcsvc/nis_callback.x
/usr/include/rpcsvc/nis_object.x
/usr/include/rpcsvc/nis_tags.h
/usr/include/rpcsvc/nislib.h
/usr/include/rpcsvc/nlm_prot.h
/usr/include/rpcsvc/nlm_prot.x
/usr/include/rpcsvc/rex.h
/usr/include/rpcsvc/rex.x
/usr/include/rpcsvc/rstat.h
/usr/include/rpcsvc/rstat.x
/usr/include/rpcsvc/rusers.h
/usr/include/rpcsvc/rusers.x
/usr/include/rpcsvc/sm_inter.h
/usr/include/rpcsvc/sm_inter.x
/usr/include/rpcsvc/spray.h
/usr/include/rpcsvc/spray.x
/usr/include/rpcsvc/yp.h
/usr/include/rpcsvc/yp.x
/usr/include/rpcsvc/yp_prot.h
/usr/include/rpcsvc/ypclnt.h
/usr/include/rpcsvc/yppasswd.h
/usr/include/rpcsvc/yppasswd.x
/usr/include/rpcsvc/ypupd.h
/usr/include/sched.h
/usr/include/scsi
/usr/include/scsi/scsi.h
/usr/include/scsi/scsi_ioctl.h
/usr/include/scsi/sg.h
/usr/include/search.h
/usr/include/semaphore.h
/usr/include/setjmp.h
/usr/include/sgtty.h
/usr/include/shadow.h
/usr/include/signal.h
/usr/include/spawn.h
/usr/include/stab.h
/usr/include/stdc-predef.h
/usr/include/stdint.h
/usr/include/stdio.h
/usr/include/stdio_ext.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/strings.h
/usr/include/sys
/usr/include/sys/acct.h
/usr/include/sys/auxv.h
/usr/include/sys/bitypes.h
/usr/include/sys/cdefs.h
/usr/include/sys/debugreg.h
/usr/include/sys/dir.h
/usr/include/sys/elf.h
/usr/include/sys/epoll.h
/usr/include/sys/errno.h
/usr/include/sys/eventfd.h
/usr/include/sys/fanotify.h
/usr/include/sys/fcntl.h
/usr/include/sys/file.h
/usr/include/sys/fsuid.h
/usr/include/sys/gmon.h
/usr/include/sys/gmon_out.h
/usr/include/sys/inotify.h
/usr/include/sys/io.h
/usr/include/sys/ioctl.h
/usr/include/sys/ipc.h
/usr/include/sys/kd.h
/usr/include/sys/kdaemon.h
/usr/include/sys/klog.h
/usr/include/sys/mman.h
/usr/include/sys/mount.h
/usr/include/sys/msg.h
/usr/include/sys/mtio.h
/usr/include/sys/param.h
/usr/include/sys/pci.h
/usr/include/sys/perm.h
/usr/include/sys/personality.h
/usr/include/sys/poll.h
/usr/include/sys/prctl.h
/usr/include/sys/procfs.h
/usr/include/sys/profil.h
/usr/include/sys/ptrace.h
/usr/include/sys/queue.h
/usr/include/sys/quota.h
/usr/include/sys/raw.h
/usr/include/sys/reboot.h
/usr/include/sys/reg.h
/usr/include/sys/resource.h
/usr/include/sys/select.h
/usr/include/sys/sem.h
/usr/include/sys/sendfile.h
/usr/include/sys/shm.h
/usr/include/sys/signal.h
/usr/include/sys/signalfd.h
/usr/include/sys/socket.h
/usr/include/sys/socketvar.h
/usr/include/sys/soundcard.h
/usr/include/sys/stat.h
/usr/include/sys/statfs.h
/usr/include/sys/statvfs.h
/usr/include/sys/swap.h
/usr/include/sys/syscall.h
/usr/include/sys/sysctl.h
/usr/include/sys/sysinfo.h
/usr/include/sys/syslog.h
/usr/include/sys/sysmacros.h
/usr/include/sys/termios.h
/usr/include/sys/time.h
/usr/include/sys/timeb.h
/usr/include/sys/timerfd.h
/usr/include/sys/times.h
/usr/include/sys/timex.h
/usr/include/sys/ttychars.h
/usr/include/sys/ttydefaults.h
/usr/include/sys/types.h
/usr/include/sys/ucontext.h
/usr/include/sys/uio.h
/usr/include/sys/ultrasound.h
/usr/include/sys/un.h
/usr/include/sys/unistd.h
/usr/include/sys/user.h
/usr/include/sys/ustat.h
/usr/include/sys/utsname.h
/usr/include/sys/vfs.h
/usr/include/sys/vlimit.h
/usr/include/sys/vm86.h
/usr/include/sys/vt.h
/usr/include/sys/vtimes.h
/usr/include/sys/wait.h
/usr/include/sys/xattr.h
/usr/include/syscall.h
/usr/include/sysexits.h
/usr/include/syslog.h
/usr/include/tar.h
/usr/include/termio.h
/usr/include/termios.h
/usr/include/tgmath.h
/usr/include/thread_db.h
/usr/include/time.h
/usr/include/ttyent.h
/usr/include/uchar.h
/usr/include/ucontext.h
/usr/include/ulimit.h
/usr/include/unistd.h
/usr/include/ustat.h
/usr/include/utime.h
/usr/include/utmp.h
/usr/include/utmpx.h
/usr/include/values.h
/usr/include/wait.h
/usr/include/wchar.h
/usr/include/wctype.h
/usr/include/wordexp.h
/usr/include/xlocale.h
[root@localhost home]# 

stdarg.h和stddef.h位于/usr/lib/gcc/i486-linux-gnu/4.3.2/include目录下，stdio.h、stdlib.h、time.h、math.h、assert.h位于/usr/include目录下。C99标准定义的头文件有24个，本书只介绍其中最基本、最常用的几个。


<netinet/in.h>主要定义了一些类型，
<arpa/inet.h>主要定义了格式转换函数。
arpa目录还有ftp.h, nameser.h, nameser_compat.h, telent.h, tftp.h
netinet目录还有ether.h, icmp6.h, if_ether.h, if_fddr.h, if_tr.h, igmp.h, in_systm.h, ip.h, ip6.h, ip_icmp.h, tcp.h, udp.h
arpa网是因特网的前身。
我觉得这些头文件都是tcp/ip协议有关



## 编译四部曲

![img](pic\C语言编译汇编过程.png)

### 预编译

预处理过程实质上是处理“#”，将#include包含的头文件直接拷贝到hell.c当中；将#define定义的宏进行替换，同时将代码中没用的注释部分删除等

具体做的事儿如下：

（1）将所有的#define删除，并且展开所有的宏定义。说白了就是字符替换

（2）处理所有的条件编译指令，#ifdef #ifndef #endif等，就是带#的那些

（3）处理#include，将#include指向的文件插入到该行处

（4）删除所有注释

（5）添加行号和文件标示，这样的在调试和编译出错的时候才知道是是哪个文件的哪一行

（6）保留#pragma编译器指令，因为编译器需要使用它们。

 **gcc -E hello.c -o a.c**可以生成预处理后的文件。



### 编译

编译的过程实质上是把高级语言翻译成机器语言的过程，即对a.c做了这些事儿

（1）词法分析，

（2）语法分析

（3）语义分析

（4）优化后生成相应的汇编代码



**gcc -S hello.c -o a.s**可以生成汇编代码



### 汇编

从 高级语言->汇编语言->机器语言（二进制）

汇编实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的**目标文件**。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成。通常一个目标文件中至少有两个段：

代码段：该段中所包含的主要是程序的指令。

该段一般是可读和可执行的，但一般却不可写。

数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。



UNIX环境下主要有三种类型的目标文件：

（1）可重定位文件（如.o文件）

其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。

（2）共享的目标文件（如.so文件）

这种文件存放了适合于在两种上下文里链接的代码和数据。第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个 目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。

（3）可执行文件（如elf文件）

它包含了一个可以被操作系统创建一个进程来执行之的文件。汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。



### 链接

将翻译成的二进制与需要用到库绑定在一块。

分为：静态链接与动态链接

**gcc hello.c -o a**可以生成可执行程序。即gcc不带任何参数。

ldd就可以看到你的可执行程序依赖的库。

（1）静态链接

在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

（2） 动态链接

在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

如下图所示，gcc编译过程

![img](pic\gcc编译过程.png)

## 程序分段与内存分段的统一



可执行文件中有分段，一般包括代码段与数据段。可通过readelf查看，包括如bss、text、data等段

内存分段，CPU硬件支持段寄存器

专门用来保存段地址：
CS（Code Segment）：代码段寄存器；
DS（Data Segment）：数据段寄存器；
SS（Stack Segment）：堆栈段寄存器； 

ES（Extra Segment）：附加段寄存器。

Intel 286引入FS与GS寄存器

当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，
通过设定段寄存器 CS，DS，SS 来指向这些起始位置。

通常是将DS固定，而根据需要修改CS。

所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。 
所以，程序和其数据组合起来的大小，限制在DS 所指的64K内，这就是COM文件不得大于64K的原因。

特殊功能的寄存器：
IP（Intruction Pointer）：指令指针寄存器，与CS配合使用，可跟踪程序的执行过程；
SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。
BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置；
SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；
DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。

还有一个标志寄存器FR（Flag Register）,有九个有意义的标志。

OF: 溢出标志位OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0.

DF: 方向标志DF位用来决定在串操作指令执行时有关指针寄存器发生调整的方向。

IF: 中断允许标志IF位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：

(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；

(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。

TF: 状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变

SF: 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。

ZF: 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。

AF: 下列情况下，辅助进位标志AF的值被置为1，否则其值为0：

(1)、在字操作时，发生低字节向高字节进位或借位时；
(2)、在字节操作时，发生低4位向高4位进位或借位时。

PF: 奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。

CF: 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。

其中，

**SS：SP指向栈顶（SS为堆栈段寄存器，SP为堆栈指针，二者一相加，就构成了堆栈栈顶的内存地址）**

**CS：IP指向下一条执行指令**

CPU在执行指令时，通过代码寄存器CS和指令指针寄存器IP（instruction Pointer）来确定要执行的下一条指令的内存地址。

　　CS:IP 两个寄存器指示了CPU当前要运行的指令地址，计算方式一般为CS左移4位然后加上IP寄存器，作为地址去取内容。

　　CPU的制造商会为这两个寄存器设置出厂初始值，这2个初始值，其实就决定了第一条执行指令的地址，这是所有程序的源头，没有这个初始值，多么复杂精妙的程序都没用，因为CPU压根就不会鸟你。随着X86的发展，第一条指令并不是一成不变的，

　　（1）8086：CPU reset后CS寄存器的值为0xFFFF，IP寄存器的值为0，所以将CS左移4位+IP，换算出的物理地址为0xFFFF0，这个地址就是1MB往下16字节的位置。

　　（2）80286：CPU reset之后CS的只为0xF000，IP的只为0xFFF0，算法同样是CS左移4位+IP，计算出的物理地址也是0xFFFF0

　　（3）80386：到了386年代，一切都变了，此时CPU reset后CS的只为0xF000，但是CS除了段选择之外还有一个隐藏的基址寄存器，这个寄存器的值为0xFFFF0000，IP的值仍然为0xFFF0，此时的计算算法也不是上面的左移4位了，而是0xFFFF0000 + 0xFFF0 = 0xFFFFFFF0，这个地址已经是很高的地址了，是4G往下16字节的位置。

**参见**《Intel® 64 and IA-32 architectures software developer’s manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4》9.1.4 First Instruction Executed

https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html

【附】PC寄存器　

PC是非intel厂家对IP的称呼，也就是说PC起始跟CS:IP是一回事儿。如ARM架构的CPU



CPU运行

对于X86的CPU开始运行，进入BIOS的实模式，其寻址范围是1M，对应将BIOS映射（BIOS存放在ROM，运行时将ROM进行地址映射）到4G内存空间的最高1M，即是4G往下16字节的位置（执行BIOS入口地址）。



#### 第一条指令

从物理上来讲，F0000 ~ FFFFFh 映射到 FFFF0000 ~ FFFFFFFFh 靠**硬件来保证**，在地址解码时，F0000 ~ FFFFFh 与 FFFF0000 ~ FFFFFFFFh 会被解码到同一个区域。现在的芯片组提供的厂商有很多，如：Intel，AMD，nvidia，VIA，SIS 等，它们的解码实现方法可能会不同，但都要保证这个所谓的“别名”机制。

80386及之后的CPU，CS：IP复位后，执行的第一条指令地址为0xFFFFFFF0（也即FFFF0，执行BIOS的入口地址），其内容是jmp far ptr F000:E05B，跳转到地址FE05B（BIOS程序开始执行的地址）。**第一条指令**的 FFFFFFF0 与 第二条的 FE05B 都是在 BIOS 的 ROM 上。

总结：AMI的legacy BIOS中**第一条指令**在BIOS文件（1MByte）offset 000ffff0的地方，整个BIOS ROM会被decode到系统memory地址的fff0_0000~ffff_ffff段，最后**第一条指令**刚好就在CPU reset后取指令的地方ffff_fff0了。所以只要BIOS的**第一条指令**在上电时能被解码到ffff_fff0的地方就可以了。

**参见**《Intel® 64 and IA-32 architectures software developer’s manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4》9.10 INITIALIZATION AND MODE SWITCHING EXAMPLE



BIOS代码肯定是储存在EPROM中的，这时cpu如何访问？靠**地址映射**，硬件会把EPROM映射在两个地方，一个是从0xFFFFFFFF(4GB)处向下扩展，一个是从0xFFFFF(1MB)处向下扩展。

The system BIOS region is a single, 64-KB segment. This segment can be assigned read and write
attributes. It is by default (after reset) read/write disabled and cycles are forwarded to the hub interface. By manipulating the read/write attributes, the MCH can “shadow” BIOS into system memory.

内存控制器对于1MB地址的高256KB（C0000~FFFFF）是特殊处理的，intel称之为PAM（Programmable Attribute Map） Memory Spaces，对于1MB地址的高64KB，系统复位之后，F000段的shadow状态是disabled，对这个64KB地址范围的访问，内存控制器（MCH）做了重定向处理，通过DMI（Direct Media Interface）转向到了ICH（南桥），最终通过南桥的LPC Bus定位到了装BIOS的Flash ROM。



实模式、保护模式、虚拟86模式



## 实模式

 实模式为了兼容8086，所以只支持20条地址线，2的20次方=1MB：0x00000--0xFFFFF。
下图为1M的内存如何布局的：（**1M内存空间**）
0--0x9FFFF是DRAM，大小640KB，也就是我们往主板上面插的内存条，特点是漏点快，需要刷新。
0xF0000-0xFFFFF是主板内存ROM，大小64KB，里面存的就是BIOS的代码。
0xA0000-C7FFFF是显卡的区域，包括了显卡的ROM和显存。
0xC8000-0xEFFFF是硬件适配器的ROM或内存映射式IO，每个外设都有自己的内存，包括键盘（8048、8042）、各种控制器（硬盘控制器、中断控制器）等都有自己的内存。

![img](E:\data_zjb\develop\Data_Structure_and_Algorithm\InsightStdC\pic\实模式下的内存布局.png)



### CPU启动过程

实模式  ——  BIOS  ——  MBR  ——  loader

开机后进入实模式：先运行BIOS，BIOS最后的工作是将001扇区（CHS）的MBR加载到内存0x7c00处开始运行，MBR中的程序又将loader从硬盘中加载到内存（我们设定为0x900）开始运行！





1、实模式，第一条指令0xFFFFFFF0（ROM地址映射到4G高端处），指向BIOS入口地址

2、执行第一条指令jmp far ptr F000:E05B，跳转到0xFFFFE05B，开始执行BIOS程序代码

3、检测和初始化硬件：执行外设的自检程序

4、在0x000-0x3FF处建立中断向量表IVT，并填写中断向量信息，长度为1024B，可以容纳256个中断向量

5、加载MBR，MBR长度为512字节，是（001）扇区，包括446字节的引导程序、64字节的硬盘分区表、2字节的结束标记0x55和0xaa（BIOS中的最后一条指令）

校验启动盘0盘0道1扇区的内容（001），当发现这个扇区（512B）最后两个字节是0x55和0xaa时候，BIOS便认定这是主引导程序MBR，便开始启动BISO的加载程序将001扇区的内容加载到内存0x07c00处，然后执行跳转指令：jmp 0:0x7c00,cs由0xf000变成了0x0000。（小段字节序 0xaa55）


包括初始化内存控制器、校验BIOS的其余部分是否有损坏等等，由于从复位向量开始的BIOS代码(加上几个jmp)。这是从ROM(内存控制器还没有开始)直接执行的，所以很慢。

初始化内存控制器. (如果您从主板上收到“没有检测到的内存”哔声代码,则会发生在此处.)>在压缩区域执行校验和,以确保其余的BIOS没有损坏.>如果检测到任何损坏,跳转到恢复模式.>如果校验和通过,将其余的BIOS解压缩到RAM的某处(通常低于1MB边界).>跳转到RAM中的解压缩代码并继续引导.

内存可用后，将其余的BIOS解压缩到RAM的某处(通常低于1MB边界)，在RAM中执行代码比在ROM中快。





BIOS（Basic Input Output System，基本输入输出系统）—— 存储在主板上的ROM芯片中

1）中断服务程序（中断例程）

BIOS或MBR中的程序代码功能与硬件实现的衔接，主要是使用INT指令进行实现的。

| 中断号  | 0x00 - 0x1F，共计32个中断服务                                |
| ------- | ------------------------------------------------------------ |
| INT 10H | 显示服务**Video Service**                                    |
| INT 13H | 直接磁盘服务**Direct Disk Service**                          |
| INT 14H | 串行口服务**Serial Port Service**                            |
| INT 15H | 杂项系统服务**Miscellaneous System Service**                 |
| INT 16H | 键盘服务**Keyboard Service**                                 |
| INT 17H | 并行口服务**Parallel Port Service**                          |
| INT 1AH | 时钟服务**Clock Service**                                    |
|         | 直接系统服务**Direct System Service)**                       |
|         | INT 00H —“0”作除数<br/>INT 01H —单步中断<br/>INT 02H —非屏蔽中断(NMI)<br/>INT 03H —断点中断<br/>INT 04H —算术溢出错误<br/>INT 05H —打印屏幕和BOUND越界<br/>INT 06H —非法指令错误<br/>INT 07H —处理器扩展无效<br/>INT 08H —时钟中断<br/>INT 09H —键盘输入<br/>INT 0BH —通信口(COM2:)<br/>INT 0CH —通信口(COM1:)<br/>INT 0EH —磁盘驱动器输入/输出<br/>INT 11H —读取设备配置<br/>INT 12H —读取常规内存大小(返回值AX为内存容量，以K为单位)<br/>INT 18H —ROM BASIC<br/>INT 19H —重启动系统<br/>INT 1BH —CTRL+BREAK处理程序<br/>INT 1CH —用户时钟服务<br/>INT 1DH —指向显示器参数表指针<br/>INT 1EH —指向磁盘驱动器参数表指针<br/>INT 1FH —指向图形字符模式表指针 |

2）系统设置

启动顺序等参数设置和保存



3）上电自检POST（Power on self-test）

对外设进行检查，若发现问题，给出提示信息或者蜂鸣器告警



4）系统自举

按照系统设置的启动顺序搜索硬盘、CDROM等有效的存储介质，读入操作系统引导记录，如MBR，交接系统控制权完成启动（RAM中）

jmp 0：0x7c00（32KB的最后1KB，为了兼容较早的CPU）



MBR（main boot record）—— 存储在硬盘的001扇区

DBR（dos boot record）—— 存储在硬盘的011扇区



一、MBR结构

位置：0柱面,0磁头,1扇区(clindyer 0,side 0,sector 1)

包括：主引导记录MBR(Main Boot Record)和分区表DPT(Disk Partition Table).

大小：512字节

其中：MBR 446字节(0000–01BD),DPT 64字节(01BE–01FD),结束标志2字节(55 AA)

功能：MBR通过检查DPT分区信息引导系统跳转至DBR

DBR（Dos Boot Record）是操作系统引导记录区的意思。
它通常位于硬盘的0磁道1柱面1扇区，是操作系统可以直接访问的第一个扇区，
它包括一个引导程序和一个被称为BPB（Bios Parameter Block）的本分区参数记录表。
BPB参数块记录着本分区的起始扇区、结束扇区、文件存储格式、硬盘介质描述符、根目录大小、FAT个数，分配单元的大小等重要参数。

二、linux上查看MBR
a、使用dd命令将硬盘的001扇区（512字节）导出
dd if=/dev/sda of=mbr.hex bs=512 count=1

b、查看
hexdump -C ./mbr.hex


三、制作MBR

a、使用汇编语言编程

#cat ./mbr_test.S 

mov al, 'Y'
mov ah, 0x0e
mov bx, 0x7

int 0x10

finish:
	jmp $

;;其余空间使用“0”填充
times 446-($-$$) db 0

;;分区激活标志，可引导系统
db 0x80

;;其余空间使用“0”填充
times 510-($-$$) db 0

;;最后两个特征字节使用0xaa55填充
db 0x55, 0xaa

b、使用nasm汇编编译器编译

yum install nasm

nasm -o mbr_test.bin -f bin mbr_test.S

c、使用hexdump命令查看，一致





