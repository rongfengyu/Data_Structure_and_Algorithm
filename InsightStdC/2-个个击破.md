###  深入C库函数

平台相关

指针大小与什么有关
1、cpu位数（32位数4字节，64位数8字节）
2、操作系统位数（32位数4字节，64位数8字节）
3、编译器的位数（32位数4字节，64位数8字节）
当上述3种位数不同，取最小的位数。
比如，如果CPU、系统都是64位的，但编译器是32位的，那么很显然指针只能是32位4字节大小。

内存中有各种各样的数据，整型、浮点型、字符型等等。这些数据在内存中占据不同大小的储存空间，故用sizeof运算符（注：sizeof是种运算符而不是函数，它在编译时发挥作用）进行运算时结果是不同的。然而不同类型的指针在相同系统环境下进行这种运算时结果却是相同的。为什么呢？

众所周知，C语言中的指针描述的是内存中的地址。而内存地址这种东西则是由CPU进行编址的。对于一个4位的CPU来讲，它能同时输出的数据为4位，即0000-1111共2^4 种情况，故这些二进制数字只能对应到16个位置的内存地址，即CPU仅能识别出16个内存地址。即便你的内存再大，它也显示只有16个位置的内存可用。这种原理同样应用于32位和64位的CPU。
因为指针存放的是地址，所以32位内存，共4个字节；64位系统的64位地址共8个字节——你应该明白什么了吧！没错，32位指针4字节，64位指针8字节。

注：loongson 3A3000，64位CPU，64位操作系统。32位交叉编译工具链sizof(int *) = 4，64位交叉编译工具链sizof(int *) = 8。


契约式编程   ——解决编程过程中的权责不清的问题
【扩展】防御式编程   防御式编程，就是持怀疑态度审视所有的代码（总有刁民想害朕）。

对于大型软件， 防御式编程会让编程者忙到怀疑人生，更多的可能会采用契约式编程，协商接口契约，调用者保证传参满足契约，参数不合的情况不能调用函数

前条件、后条件、不变式

契约式编程，检查前条件使用ASSERT断言，检查后条件使用异常。
断言处理不应该在程序中出现的情况，出现了程序终止、及时发现解决错误；
异常处理程序中可能出现的错误情况,出现了需要做处理

以一个函数为例，它要求在开始执行的时候满足一系列条件，这些条件被称为“前条件”或者“先验条件”，比如，参数不为空，某全局变量应该为1，等等。不满足前条件，是不能调用此函数的，如果出现了前条件不满足仍然调用了此函数，可以认为这是一个设计错误。

这个函数执行以后，也会满足一系列条件，这些条件被称为“后条件”或者“后验条件”，比如返回值满足什么关系，某全局变量设置称为什么什么，等等。这应该是函数执行的结果，在前条件满足的情况下，后条件如果没有满足是一种不正常的情况，那么使用异常来处理。

契约式编程中前条件不满足是程序错误，需要修改，这也与一般理解中出现ASSERT是程序错误符合；后条件不满足往往也是一些意外原因，也和一般理解中出现异常是意外情况符合。但是契约式编程还有一个问题是“不变式”，不变式指在函数执行之前和之后都不发生变化，我理解，在函数执行以前可以用ASSERT对不变式进行检查，在执行以后如果发现不变式发生了变化，那么应该抛出异常。


梳理程序库和组件实现的接口，清楚每个接口的输入输出限制，明确调用者的权利，以及函数库提供者的义务

比如，很多库函数并没有在内部进行指针的空值检查，需要函数调用者在调用前作出保证（调用者的义务），因此，有必要了解库函数的接口参数


一般认为在模块中检查错误状况并且上报，是模块本身的义务。而在契约体制下，对于契约的检查并非义务，实际上是在履行权利。一个义务，一个权利，差别极大。例如下面的代码：
if (dest == NULL) { ... }
　　这就是义务，其要点在于，一旦条件不满足，我方（义务方）必须负责以合适手法处理这尴尬局面，或者返回错误值，或者抛出异常。而：
assert(dest != NULL);
　　这是检查契约，履行权利。如果条件不满足，那么错误在对方而不在我，我可以立刻“撕毁合同”，罢工了事，无需做任何多余动作。这无疑可以大大简化程序库和组件库的开发。

　　契约所核查的，是“为保证正确性所必须满足的条件”，因此，当契约被破坏时，只表明一件事：软件系统中有bug。其意义是说，某些条件在到达我这里时，必须已经确保为“真”。谁来确保？应该是系统中的其他模块在先期确保。如果在我这里发现契约没有被遵守，那么表明系统中其他模块没有正确履行自己的义务。就拿上面提到的“打开文件”的例子来说，如果有一个模块需要一个FILE指针，而在契约检查中发现该指针为NULL，则意味着有一个模块没有履行其义务，即“检查文件是否存在，确保文件以正确模式打开，并且保证指针的正确性”。因此，当契约检查失败时，我们首先要知道这意味着程序错误，而且要做的不是纠正契约核查方，而是纠正契约提供方。换句话说，当你发现：assert(dest != NULL); 报错时，你要做的不是去修改你的string_copy函数，而是要让任何代码在调用string_copy时确保dest指针不为空。

引入契约之后，“过程”和“函数”被定义为：完成契约的过程。基于契约的相互性，如果这个契约的失败是因为其他模块未能履行契约，本过程只需报告，无需以任何其他方式做出反应。而真正的异常状况是“对方完全满足了契约，而我依然未能如约完成任务”的情形。

一般来说，在面向对象技术中，我们认为“接口”是唯一重要的东西，接口定义了组件，接口确定了系统，接口是面向对象中我们唯一需要关心的东西，接口不仅是必要的，而且是充分的。然而，契约观念提醒我们，仅仅有接口还不充分，仅仅通过接口还不足以传达足够的信息，为了正确使用接口，必须考虑契约。只有考虑契约，才可能实现面向对象的目标：可靠性、可扩展性和可复用性。反过来，“没有契约的复用根本就是瞎胡闹。（Bertrand Meyer语）”。

通俗来说，调用者使用提供的函数接口，则需要满足函数的契约（一般是对于输入参数的限制），否则为满足异常参数输入而对函数接口本身进行修改以适应是没有意义的。


assert
头文件#include<assert.h>

assert(expression)
如果断言表达式expression的值为真，则断言失败，则程序将会终止。

在debug模式下，当程序运行到assert(expression)这条代码时，就会计算expression这个表达式的值，如果它的值为0，则中断执行。
在release模式下，assert(expression)不会被编译进代码，在该模式下，编译器会对代码进行优化，assert对应的宏不会被执行。

每个assert()只能检验一个条件，若同时检验多个条件，如果断言失败，则无法判断出是由那个式子失败引起的。

不能将变量运算放在assert的表达式中。

assert()是用来避免在程序运行时产生的错误，而不是用来处理异常的。
错误是在编程中不应该出现的，而异常在编程中有时候是无法避免的。在C语言中产生的异常可以通过条件判断语句来进行处理。




指针为空的判断用assert还是if
```c
int MyFunc(int *p)
{
    //方式1:
    assert(NULL != p);
    //方式2:
    if(NULL == p)
    {
        return -1;
    }
}
```
内部函数，能确保指针非空，用断言。
对外提供的函数，万一其它模块传的是空就悲剧了，需要判断参数的有效性，无效的要返回。
接口函数要保证健壮性，非接口函数要确保没有被别人调用，就可以用断言。


程序运行时的错误与异常

错误：
代码错误


异常：与一般正常运行时的现象不一致

1. 运行时产生除0的情况 
2. 需要打开的外部文件不存在 
3. 数组访问时越界，输入值范围检查
4. 内存分配malloc失败检查

在C语言中异常处理一般有这么几种方式：

1.使用标准C库提供了abort()和exit()两个函数，它们可以强行终止程序的运行，其声明处于<stdlib.h>头文件中。

2.使用assert(断言)宏调用，位于头文件<assert.h>中，当程序出错时，就会引发一个abort（）。

3.使用errno全局变量，由C运行时库函数提供，位于头文件<errno.h>中。

4.使用goto语句，当出错时跳转。

5.使用setjmp,longjmp进行异常处理。


assert用法总结

1)在函数开始处检验传入参数的合法性
在函数中使用断言来检查参数的合法性是断言最主要的应用场景之一，它主要体现在如下 3 个方面：

在代码执行之前或者在函数的入口处，使用断言来检查参数的合法性，这称为前置条件断言。
在代码执行之后或者在函数的出口处，使用断言来检查参数是否被正确地执行，这称为后置条件断言。
在代码执行前后或者在函数的入出口处，使用断言来检查参数是否发生了变化，这称为前后不变断言。(如某个变量的变化范围)

2)每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败

3)不能使用改变环境的语句,因为assert只在DEBUG模式生效,如果这么做,会使用程序在真正运行时遇到问题

4)assert和后面的语句应空一行,以形成逻辑和视觉上的一致感　

5)有的地方,assert不能代替条件过滤，（如文件不存在打开失败，malloc返回失败，一些异常返回空指针的判断）

6)断言语句不可以有任何边界效应


一个场景：
如果在malloc的时候，已经判断了返回的指针不为空（内存分配成功），则在后续调用strcpy，memcpy等函数时，就不会出现传入参数指针为空的情况了！！！

memcpy、strcpy等库函数实现，其内部并没有对传入参数指针进行空指针判断，因此，它默认调用者的传参是不为空的！！！调用者自行对传入参数的非空负责！！！



memcpy

防止两个问题：

1、防止拷贝的长度溢出

2、防止没有正常结束符，从而导致溢出

方法一：字符数组初始化置0  或者 动态内存malloc分配后memset置0（calloc）

方法二：memcpy拷贝后，在最后一个字符后面置0





几种使用场景

一、固定分配buf，拷贝多少由buf与源字符串一起决定，缺点是容易造成拷贝截断

(strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str)



二、根据源字符串的大小来分配buf，长度由源字符串的长度来决定，缺点是容易无限制的拷贝



总结：不管怎样，对拷贝字符串的长度都应该作出限制！不可能无限制



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TEST_2
	
int main(void)
{
	#define BUF_LEN 200

#ifndef TEST_2
	
	printf("test method 1\n");
    char buf[BUF_LEN] = {0};//注意初始化，避免最后需要操作最后一个字符
	
#else
	
	printf("test method 2\n");
	char *buf = (char *)malloc(BUF_LEN * sizeof(char));
	if(!buf)
		return 0;
	
	memset(buf, 0, BUF_LEN);
	
#endif
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str));
	
	printf("%s\n",buf);

#ifdef TEST_2

	free(buf);
	buf = NULL;
	
#endif
	
    return 0;
}
```



malloc与free





sscanf sprintf
自动给读出的数据末尾添加\0

```c
#include <stdio.h>
void main()
{	
	char str[] = "1234567";
	sscanf("12345+acc","%[1-9]",str);
    printf("str = %s\n",str);
	
	int i = 0;
	for(;i<sizeof str; i++)
		printf(" %x", str[i]);
}

str = 12345
31 32 33 34 35 0 37 0
```

_vsnprintf

常用于输入参数变长的打印函数，拷贝LEN-1个字符，结尾自动添加‘\0’

```c
#include <stdio.h>
#include <stdarg.h>

#define MAXLEN 5

int mon_log(char* format, ...)
{
    char str_tmp[MAXLEN];
    int i=0,j=0;
    va_list vArgList;                           
    va_start (vArgList, format);                 
    i=vsnprintf(str_tmp, MAXLEN, format, vArgList);  
    va_end(vArgList);                            

    printf("%s\n", str_tmp);  //黄色高亮部分代码

    for(j=0;j<MAXLEN;j++)
    {
        printf("%d  ", str_tmp[j]);
    }
    printf("\n");
    return i;
}

void main()
{   
    int i=mon_log("%s,%d,%d,%c","abcdefghij",2,3,'\n');  //绿色高亮部分代码  
    printf("%d\n",i);
}
```



fread

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(){
    FILE *fp;
    fp = fopen("hello.txt","rt");   //文件里写1234567890
    //求得文件的大小
    fseek(fp,0,SEEK_END);//移至文件末尾
    int size = ftell(fp);//求取文件大小
    printf("size:%d\n",size);//11,包括结束符
    rewind(fp);//重置到文件流开头
    //申请一块能装下整个文件的空间 
    char *ar = (char *)malloc(sizeof(char)*size);
    //读文件，每次读一个，共读size次 
 
    fread(ar,1,5,fp);//fread读取后，文件位置会自动向文件尾移动
    printf("%s\n",ar);  //会打印12345
 
    fread(ar,1,5,fp);
    printf("%s\n",ar);  //会打印67890
    free(ar);
    fclose(fp);
    return 0;
}
```



#include <stdio.h>
#include <string.h>
 
int main(void)
{
    FILE *stream;
 
    char msg[]="this is a test";
  
    char buf[20];
  
    if((stream=fopen("test.txt","w+"))==NULL)
    {
        fprintf(stderr,"Can not open output file.\n");
        return 0; 
    }

    /*write some data to the file*/
    fwrite(msg,1,strlen(msg)+1,stream);

    /*sizeof（char）=1 seek to the beginning of the file*/

    fseek(stream,0,SEEK_SET);

    /*read the data and display it*/
    fread(buf,1,strlen(msg)+1,stream);

    printf("%s\n",buf);

    fclose(stream);

    return 0;
}


memcpy拷贝防止溢出的问题

#include <stdio.h>
#include <string.h>
 
int main(void)
{
  
    char buf[5] = {0};//注意初始化，避免最后需要操作最后一个字符
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > sizeof(buf)) ? (sizeof(buf) - 1) : strlen(src_str));
	
	printf("%s\n",buf);

    return 0;
}


strncpy

```c
//from glibc-2.31  string/strncpy.c
char *
STRNCPY (char *s1, const char *s2, size_t n)
{
  size_t size = __strnlen (s2, n);//此处的风险是，并没有算上s2的NULL结束符
  if (size != n)
    memset (s1 + size, '\0', n - size);
  return memcpy (s1, s2, size);
}
```

参数1：char *s1，目的字符串指针，调用者保证指针不为空
参数2：char *s2，源字符串指针，可为空但无实际意义
参数3：size_t n，字符串拷贝长度



对调用者的要求：

长度限制：0 、 strlen(s2) 、 sizeof(s1) 、 n，四者之间的关系

strncpy(s1, s2, n)

0）保证n不大于s1的所占空间，即sizeof(s1)>=n
进一步，如果要避免栈空间溢出，保证sizeof(s1)>n

例如，
memset(s1, 0, sizeof(s1))
strncpy(s1, s2, sizeof(s1)-1);//strlen(s2) <= sizeof(s1)-1,正常拷贝;strlen(s2) > sizeof(s1)-1,拷贝截断

1）正常拷贝，不存在拷贝截断
0 <= strlen(s2) <= n <= sizeof(s1)-1

如果strlen(s2)小于n个字节，则以NULL填充s1直到复制完n个字节(并不意味着s1的后面空间全部是NULL哦！！！)


2)拷贝截断，注意最后一个字符的处理
strlen(s2) > sizeof(s1)-1 > n
拷贝截断时，不会在dst末尾添加'\0'

3）避免拷贝截断
先计算出s2的串长度，再使用malloc分配s1的空间，保证有充足的空间

例如，
char *s1 = malloc(sizeof(char) * (strlen(s2) + 1))//strlen不包含结尾'\0'
strncpy(s1, s2, strlen(s2));//strncpy会自动将后续置为'\0'


空间限制：s1与s2的占有空间不能重叠


深入理解strncpy这个函数
https://blog.csdn.net/weibo1230123/article/details/80382614

是否考虑内存重叠

是否考虑目的空间尺寸？

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    //char *dst = NULL;
    char dst[10] = {0};
    char *ret  = NULL;
    ret = strncpy(dst, "hello", 8);
    printf("ret = %s\n", ret);//ret = hello

    memset(dst, 'a', 10);
    ret = strncpy(dst, "xxxx", 2);
    printf("ret = %s\n", ret);//ret = xxaaaaaaaa

    char *s1 = NULL;
    char *s2 = "qwertyuiop";

    s1 = malloc(sizeof(char) * (strlen(s2) + 1));
    //ret = strncpy(s1, s2, strlen(s2));
    ret = strncpy(s1, s2, strlen(s2)+1);
    printf("ret = %s\n", ret);//ret = qwertyuiop

    free(s1);
    s1=NULL;

    memset(dst, 'a', 10);
    ret = strncpy(dst, "yyyy", strlen("yyyy"));//没有结束符，存在溢出
    printf("ret = %s\n", ret);//ret = yyyyaaaaaa

    memset(dst, 'a', 10);
    ret = strncpy(dst, "yyyy", strlen("yyyy")+1);//第三个参数长度包括了结束符，处理了结束符，不存在溢出
    printf("ret = %s\n", ret);//ret = yyyy

    memset(dst, 'a', 10);
    printf("dst[7] = 0x%x\n", dst[7]);//dst[7] = 0x61
    ret = strncpy(dst, "zzzz", 10);
    printf("dst[7] = 0x%x\n", dst[7]);//dst[7] = 0x0
    printf("ret = %s\n", ret);//ret = zzzz

    memset(dst, 'a', 10);
    printf("dst[7] = 0x%x\n", dst[7]);//dst[7] = 0x61
    ret = strncpy(dst, "zzzz", 6);//不会处理dst超过n（=6）的空间
    printf("dst[7] = 0x%x\n", dst[7]);//dst[7] = 0x61
    printf("ret = %s\n", ret);//ret = zzzz

    memset(dst, 'a', 10);
    dst[10] = 'a';
    dst[11] = 'b';
    dst[12] = 'c';
    dst[13] = 'd';
    dst[14] = 'e';
    dst[15] = 'f';//x86 gcc编译器在分配字符数组时，不足16字节补足16字节
    printf("dst[10] = 0x%x\n", dst[10]);//dst[10] = 0x61
    ret = strncpy(dst, "123456789ABCD", 10);
    printf("dst[10] = 0x%x\n", dst[10]);//dst[10] = 0x61
    printf("ret = %s\n", ret);//123456789Aabcdef	@  存在溢出的情况！！！

    return 0;
}

```

sizeof

1）sizeof是种运算符而不是函数，它在编译时发挥作用

2）sizeof退化问题：（字符串、数组）在函数传参时是地址传递（指针传递），所以此时 sizeof 的作用对象实际上是指针而不是原来的字符串或者是数组

3）sizeof与内存字节对齐

为什么要字节对齐
需要字节对齐的根本原因在于CPU访问数据的效率问题。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误。

编译器的影响 

结构体的对齐准则



memcmp，strcmp

【扩展】信息安全-timing attack计时攻击
计时攻击 属于旁路攻击的一种, 所谓旁路攻击就是通过对系统的物理学分析和实现方式分析, 而不是密码学分析或暴力破解, 来尝试破解密码学系统的行为. 密码学系统的电力消耗, 电磁波泄露, 时间差等信息都有可能提供对破解系统有帮助的信息.
该函数作用是: 当首次发现字符串中有两个字符不一致时, 便直接返回两个字符在 ASCII 码表中的差值. 在这样的机制下, CPU 运行的时间与字符串匹配度是有正关系的, 字符串匹配度越高, CPU 运行时间越长, 因此便可以通过对比时间差的方式逐一猜测破解.

预防计时攻击的方法通常也很简单, 使用 Constant-Time 的方式. 如上述比较摘要是否相等的示例代码, 当发现两个字符不一致时, 并没有立即返回, 而是继续比较下去, 因此使得计算时间不会变化.

虽然这样的处理, 时间复杂度提高了, 在语言级别的效率也降低了, 但在系统安全的关键部分, 付出了一点点性能的代价还是值得的.

也许你会觉得不解(我也是), 每个请求在不同的情况下包括网络延迟, 计算机运行状态都是不可能完全一致的, 
况且这么一点点的时间差在 Rails 处理整个复杂的请求过程中(你应该知道, 在 Rails 中一个请求可能生成数以万计的 Ruby 对象)也显得非常的微不足道, 应该是非常难以利用的, 计时攻击难道仅仅存活在理论当中吗? 

public static boolean isEqual(byte[] a, byte[] b) {
    if (a.length != b.length) {
        return false;
    }

    int result = 0;
    for (int i = 0; i < a.length; i++) {//Constant-Time
      result |= a[i] ^ b[i]
    }
    return result == 0;}
	
任何java程序(通过MessageDigest.isEqualis比较客户端提供数据和加密值比较的) 都是容易受到计时攻击的. 这里包括 HMACs, 解密结果, 等等.

还有一个重要使用场景是验证签名 cookie 的有效性, 即外部传入的摘要与内部计算的摘要是否相等。



段页式内存管理机制

linux下内存管理是通过虚存管理的，在分配内存是并非在物理内存开辟了一段空间，而是在使用时才分配的，而且是通过段页式管理。

在linux下内存分配是以页为单位的，而页是通过段管理，各个段之间是独立的，方便管理。linux程序运行时，可以分为以下几个内存段：

一、BSS段 （bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

    该段用于存储未初始化的全局变量或者是默认初始化为0的全局变量，它不占用程序文件的大小，但是占用程序运行时的内存空间。
	
二、data段 该段用于存储初始化的全局变量，初始化为0的全局变量出于编译优化的策略还是被保存在BSS段


#define DEBUG "debug"

int space[1024][1024];//BSS段
int data = 1;//data段
int no_data = 0;//BSS段

int main()
{
  char *a = DEBUG;
  return 1;
}

三、.rodata段

该段也叫常量区，用于存放常量数据，ro就是Read Only之意。但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：
1）有些立即数与指令编译在一起直接放在代码段。
int main()
{
  int a = 10;//代码段
  return 1;
}
a是常量，但是它没有被放入常量区，而是在指令中直接通过立即数赋值

2）对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份。
char *str = "123456789";//rodata段
char *str1 = "helloworld";//rodata段

int main()
{
  char* a = "helloworld";//rodata段，与str1指向同一份
  char b[10] = "helloworld";//代码段
  return 1;
}
str1和a同时指向.rodata段中同一个LC1，而是用数组初始化的字符串常量是没有放入常量区的，另外用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。

3）有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率。

四、text段

text段是用于存放程序代码的，编译时确定,只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，
与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

五、stack段

也就是栈段，常说的堆栈段之一，是由系统负责申请释放，其操作方式类似stack，用于存储参数变量及局部变量，其实函数的执行也是stack的方式，所以才有了递归

六、heap段

也就是俗称的堆，它由用户申请和释放，申请时至少分配虚存，当真正存储数据时才分配相应的实存，释放时也并非立即释放实存，而是可能被重复利用，待后续会再仔细介绍相关的知识。

堆和栈的内存增长方向是相反的。


#include <stdio.h>
#include <stdlib.h>

int main () {
	char s1[] = "aaaaaaaaaaaaaaa";//栈区
	char *s2 = "bbbbbbbbbbbbbbbbb";//rodata段
	char *s3 = NULL;
	s3 = malloc(10*sizeof(char));//堆区
	printf("%p  %p %p", s1, s2, s3);//s1,s3每次运行结果都不一样，s2保持不变！  s2<s3<s1
	
	char a = 1;
	a=s1[1];
	a=s2[1];//比上一条语句执行慢
	return 0;
}
aaaaaaaaaaa是在运行时刻赋值的；（栈区）
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。

堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度
使用堆，需要关心内存的分配以及释放，相比代码中写死的数组空间，更具有灵活性

申请效率的比较：
栈由系统自动分配，速度较快。但程序员是无法控制的。

堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.


nm命令

B  bss段
D  data段


比较程序
#include <stdio.h>
char *returnStr()
{
char *p="hello world!";//字符串常量"hello world!"在rodata段，指针p指向其地址，子函数退出后，指针指向的地址空间依然存在
return p;
}
int main()
{
char *str=NULL;//一定要初始化，好习惯
str=returnStr();
printf("%s\n", str);//不会出错！

return 0;
}
与
#include <stdio.h>
char *returnStr()
{
char p[]="hello world!";//字符数组p为局部变量，分配在栈区，空间在子函数退出后被释放。字符串常量"hello world!"在此处是rodata中字符串常量"hello world!"的一个拷贝！
return p;
}
int main()
{
char *str=NULL;//一定要初始化，好习惯
str=returnStr();
printf("%s\n", str);//地址已被释放，要出错！

return 0;
}
说明：
"hello world!"是一个字符串常量，存放在静态数据区，没错，
但是把一个字符串常量赋值给了一个局部变量(char []型数组)，该局部变量存放在栈中，
这样就有两块内容一样的内存，也就是说“char p[]="hello world!";”这条语句让“hello world!”这个字符串在内存中有两份拷贝，一份在动态分配的栈中，另一份在静态存储区。这是与前者最本质的区别，
当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，
所以这时的函数返回的是一个已被释放的内存地址，所以打印出来的是乱码。

#include <stdio.h>
#include <stdlib.h>

int main () {	
	char xx1[] = "hello";
	char * xx2 = "hello";
	printf("%p %p %p", xx1, xx2, &("hello"));//xx1 != xx2 == &("hello")
	return 0;
}

指令连续，数据不连续（编译器字节对齐补零）
为了对齐，编译器在程序中塞了好多0。是的，对齐确实是让程序中出现了好多空隙，但这些空隙是数据间的空隙，指令间不存在空隙，
下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是Intel处理器的程序计数器cs：eip能够自动获得下一条指令的原理，即将当前eip中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址。
即使指令间有空隙或其他非指令的数据，这也仅仅是在物理上将其断开了，依然可以用jmp指令将非指令部分跳过以保持指令在逻辑上连续。

正则表达式匹配

标准的C和C++都不支持正则表达式，但有一些函数库可以辅助C/C++程序员完成这一功能，其中最著名的当数Philip Hazel的Perl-Compatible Regular Expression库，许多Linux发行版本都带有这个函数库。
C语言处理正则表达式常用的函数有regcomp()、regexec()、regfree()和regerror()，一般分为三个步骤，如下所示：

C语言中使用正则表达式一般分为三步：
编译正则表达式 regcomp()
匹配正则表达式 regexec()
释放正则表达式 regfree()
https://www.jb51.net/article/138515.htm
下边是对三个函数的详细解释

1、int regcomp (regex_t *compiled, const char *pattern, int cflags)

这个函数把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效。函数regexec 会使用这个数据在目标文本串中进行模式匹配。执行成功返回０。 　

参数说明：

①regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。
②pattern 是指向我们写好的正则表达式的指针。
③cflags 有如下4个值或者是它们或运算(|)后的值：
REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。
REG_ICASE 匹配字母时忽略大小写。
REG_NOSUB 不用存储匹配后的结果。
REG_NEWLINE 识别换行符，这样'$'就可以从行尾开始匹配，'^'就可以从行的开头开始匹配。

2. int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)

当我们编译好正则表达式后，就可以用regexec 匹配我们的目标文本串了，如果在编译正则表达式的时候没有指定cflags的参数为REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。
regmatch_t 是一个结构体数据类型，在regex.h中定义：

typedef struct
{
regoff_t rm_so;
regoff_t rm_eo;
} regmatch_t;

成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。

参数说明：

①compiled 是已经用regcomp函数编译好的正则表达式。
②string 是目标文本串。
③nmatch 是regmatch_t结构体数组的长度。
④matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。
⑤eflags 有两个值
REG_NOTBOL 按我的理解是如果指定了这个值，那么'^'就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；
REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。
3. void regfree (regex_t *compiled)

当我们使用完编译好的正则表达式后，或者要重新编译其他正则表达式的时候，我们可以用这个函数清空compiled指向的regex_t结构体的内容，请记住，如果是重新编译的话，一定要先清空regex_t结构体。

4. size_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)

当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。

参数说明：
①errcode 是由regcomp 和 regexec 函数返回的错误代号。
②compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。
③buffer 指向用来存放错误信息的字符串的内存空间。
④length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。

size_t length = regerror (errcode, compiled, NULL, 0);

```c
//字符串的正则表达式匹配操作函数，传入参数为待匹配字符串与pattern
bool CUtils::isRegMatch(string TargetStr, string PatternStr)
{
    int ret = 1;//以防不测
    
    //for regex
    regmatch_t pmatch;
    regex_t reg;

    //regex: format check!
    ret = regcomp(&reg, (char *)PatternStr.c_str(), REG_EXTENDED);
    if(ret != 0)
        return false;
    
    ret = regexec(&reg, (char *) TargetStr.c_str(), 1, &pmatch, 0);

    regfree(&reg);

    if (ret == 0)//matched!
    {
        return true;
    }

    return false;
}
```


熟能生巧、事半功倍、减少返工



专题——平台相关的函数使用

专题——配对使用函数

专题——内存分配与释放

专题——安全使用函数

专题——格式化输入输出控制

专题——指针

专题——