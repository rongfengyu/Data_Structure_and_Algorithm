###  深入C库函数

平台相关


assert

指针为空的判断用assert还是if
```c
int MyFunc(int *p)
{
    //方式1:
    assert(NULL != p);
    //方式2:
    if(NULL == p)
    {
        return -1;
    }
}
```
内部函数，能确保指针非空，用断言。
对外提供的函数，万一其它模块传的是空就悲剧了，需要判断参数的有效性，无效的要返回。
接口函数要保证健壮性，非接口函数要确保没有被别人调用，就可以用断言。

memcpy

防止两个问题：

1、防止拷贝的长度溢出

2、防止没有正常结束符，从而导致溢出

方法一：字符数组初始化置0  或者 动态内存malloc分配后memset置0（calloc）

方法二：memcpy拷贝后，在最后一个字符后面置0





几种使用场景

一、固定分配buf，拷贝多少由buf与源字符串一起决定，缺点是容易造成拷贝截断

(strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str)



二、根据源字符串的大小来分配buf，长度由源字符串的长度来决定，缺点是容易无限制的拷贝



总结：不管怎样，对拷贝字符串的长度都应该作出限制！不可能无限制



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TEST_2
	
int main(void)
{
	#define BUF_LEN 200

#ifndef TEST_2
	
	printf("test method 1\n");
    char buf[BUF_LEN] = {0};//注意初始化，避免最后需要操作最后一个字符
	
#else
	
	printf("test method 2\n");
	char *buf = (char *)malloc(BUF_LEN * sizeof(char));
	if(!buf)
		return 0;
	
	memset(buf, 0, BUF_LEN);
	
#endif
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str));
	
	printf("%s\n",buf);

#ifdef TEST_2

	free(buf);
	buf = NULL;
	
#endif
	
    return 0;
}
```



malloc与free





sscanf sprintf
自动给读出的数据末尾添加\0

```c
#include <stdio.h>
void main()
{	
	char str[] = "1234567";
	sscanf("12345+acc","%[1-9]",str);
    printf("str = %s\n",str);
	
	int i = 0;
	for(;i<sizeof str; i++)
		printf(" %x", str[i]);
}

str = 12345
31 32 33 34 35 0 37 0
```

_vsnprintf

常用于输入参数变长的打印函数，拷贝LEN-1个字符，结尾自动添加‘\0’

```c
#include <stdio.h>
#include <stdarg.h>

#define MAXLEN 5

int mon_log(char* format, ...)
{
    char str_tmp[MAXLEN];
    int i=0,j=0;
    va_list vArgList;                           
    va_start (vArgList, format);                 
    i=vsnprintf(str_tmp, MAXLEN, format, vArgList);  
    va_end(vArgList);                            

    printf("%s\n", str_tmp);  //黄色高亮部分代码

    for(j=0;j<MAXLEN;j++)
    {
        printf("%d  ", str_tmp[j]);
    }
    printf("\n");
    return i;
}

void main()
{   
    int i=mon_log("%s,%d,%d,%c","abcdefghij",2,3,'\n');  //绿色高亮部分代码  
    printf("%d\n",i);
}
```



fread

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(){
    FILE *fp;
    fp = fopen("hello.txt","rt");   //文件里写1234567890
    //求得文件的大小
    fseek(fp,0,SEEK_END);//移至文件末尾
    int size = ftell(fp);//求取文件大小
    printf("size:%d\n",size);//11,包括结束符
    rewind(fp);//重置到文件流开头
    //申请一块能装下整个文件的空间 
    char *ar = (char *)malloc(sizeof(char)*size);
    //读文件，每次读一个，共读size次 
 
    fread(ar,1,5,fp);//fread读取后，文件位置会自动向文件尾移动
    printf("%s\n",ar);  //会打印12345
 
    fread(ar,1,5,fp);
    printf("%s\n",ar);  //会打印67890
    free(ar);
    fclose(fp);
    return 0;
}
```



#include <stdio.h>
#include <string.h>
 
int main(void)
{
    FILE *stream;
 
    char msg[]="this is a test";
  
    char buf[20];
  
    if((stream=fopen("test.txt","w+"))==NULL)
    {
        fprintf(stderr,"Can not open output file.\n");
        return 0; 
    }

    /*write some data to the file*/
    fwrite(msg,1,strlen(msg)+1,stream);

    /*sizeof（char）=1 seek to the beginning of the file*/

    fseek(stream,0,SEEK_SET);

    /*read the data and display it*/
    fread(buf,1,strlen(msg)+1,stream);

    printf("%s\n",buf);

    fclose(stream);

    return 0;
}


memcpy拷贝防止溢出的问题

#include <stdio.h>
#include <string.h>
 
int main(void)
{
  
    char buf[5] = {0};//注意初始化，避免最后需要操作最后一个字符
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > sizeof(buf)) ? (sizeof(buf) - 1) : strlen(src_str));
	
	printf("%s\n",buf);

    return 0;
}


strncpy

深入理解strncpy这个函数
https://blog.csdn.net/weibo1230123/article/details/80382614

是否考虑内存重叠

是否考虑目的空间尺寸？


正则表达式匹配

标准的C和C++都不支持正则表达式，但有一些函数库可以辅助C/C++程序员完成这一功能，其中最著名的当数Philip Hazel的Perl-Compatible Regular Expression库，许多Linux发行版本都带有这个函数库。
C语言处理正则表达式常用的函数有regcomp()、regexec()、regfree()和regerror()，一般分为三个步骤，如下所示：

C语言中使用正则表达式一般分为三步：
编译正则表达式 regcomp()
匹配正则表达式 regexec()
释放正则表达式 regfree()
https://www.jb51.net/article/138515.htm
下边是对三个函数的详细解释

1、int regcomp (regex_t *compiled, const char *pattern, int cflags)

这个函数把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效。函数regexec 会使用这个数据在目标文本串中进行模式匹配。执行成功返回０。 　

参数说明：

①regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。
②pattern 是指向我们写好的正则表达式的指针。
③cflags 有如下4个值或者是它们或运算(|)后的值：
REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。
REG_ICASE 匹配字母时忽略大小写。
REG_NOSUB 不用存储匹配后的结果。
REG_NEWLINE 识别换行符，这样'$'就可以从行尾开始匹配，'^'就可以从行的开头开始匹配。

2. int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)

当我们编译好正则表达式后，就可以用regexec 匹配我们的目标文本串了，如果在编译正则表达式的时候没有指定cflags的参数为REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。
regmatch_t 是一个结构体数据类型，在regex.h中定义：

typedef struct
{
regoff_t rm_so;
regoff_t rm_eo;
} regmatch_t;

成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。

参数说明：

①compiled 是已经用regcomp函数编译好的正则表达式。
②string 是目标文本串。
③nmatch 是regmatch_t结构体数组的长度。
④matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。
⑤eflags 有两个值
REG_NOTBOL 按我的理解是如果指定了这个值，那么'^'就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；
REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。
3. void regfree (regex_t *compiled)

当我们使用完编译好的正则表达式后，或者要重新编译其他正则表达式的时候，我们可以用这个函数清空compiled指向的regex_t结构体的内容，请记住，如果是重新编译的话，一定要先清空regex_t结构体。

4. size_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)

当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。

参数说明：
①errcode 是由regcomp 和 regexec 函数返回的错误代号。
②compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。
③buffer 指向用来存放错误信息的字符串的内存空间。
④length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。

size_t length = regerror (errcode, compiled, NULL, 0);

```c
//字符串的正则表达式匹配操作函数，传入参数为待匹配字符串与pattern
bool CUtils::isRegMatch(string TargetStr, string PatternStr)
{
    int ret = 1;//以防不测
    
    //for regex
    regmatch_t pmatch;
    regex_t reg;

    //regex: format check!
    ret = regcomp(&reg, (char *)PatternStr.c_str(), REG_EXTENDED);
    if(ret != 0)
        return false;
    
    ret = regexec(&reg, (char *) TargetStr.c_str(), 1, &pmatch, 0);

    regfree(&reg);

    if (ret == 0)//matched!
    {
        return true;
    }

    return false;
}
```


熟能生巧、事半功倍、减少返工



专题——平台相关的函数使用

专题——配对使用函数

专题——内存分配与释放

专题——安全使用函数

专题——格式化输入输出控制

专题——指针

专题——