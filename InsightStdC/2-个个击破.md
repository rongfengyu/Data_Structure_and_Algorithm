###  深入C库函数



平台相关



memcpy

防止两个问题：

1、防止拷贝的长度溢出

2、防止没有正常结束符，从而导致溢出

方法一：字符数组初始化置0  或者 动态内存malloc分配后memset置0（calloc）

方法二：memcpy拷贝后，在最后一个字符后面置0





几种使用场景

一、固定分配buf，拷贝多少由buf与源字符串一起决定，缺点是容易造成拷贝截断

(strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str)



二、根据源字符串的大小来分配buf，长度由源字符串的长度来决定，缺点是容易无限制的拷贝



总结：不管怎样，对拷贝字符串的长度都应该作出限制！不可能无限制



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TEST_2
	
int main(void)
{
	#define BUF_LEN 200

#ifndef TEST_2
	
	printf("test method 1\n");
    char buf[BUF_LEN] = {0};//注意初始化，避免最后需要操作最后一个字符
	
#else
	
	printf("test method 2\n");
	char *buf = (char *)malloc(BUF_LEN * sizeof(char));
	if(!buf)
		return 0;
	
	memset(buf, 0, BUF_LEN);
	
#endif
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str));
	
	printf("%s\n",buf);

#ifdef TEST_2

	free(buf);
	buf = NULL;
	
#endif
	
    return 0;
}
```



malloc与free





sscanf



_vsnprintf

常用于输入参数变长的打印函数，拷贝LEN-1个字符，结尾自动添加‘\0’

```c
#include <stdio.h>
#include <stdarg.h>

#define MAXLEN 5

int mon_log(char* format, ...)
{
    char str_tmp[MAXLEN];
    int i=0,j=0;
    va_list vArgList;                           
    va_start (vArgList, format);                 
    i=vsnprintf(str_tmp, MAXLEN, format, vArgList);  
    va_end(vArgList);                            

    printf("%s\n", str_tmp);  //黄色高亮部分代码

    for(j=0;j<MAXLEN;j++)
    {
        printf("%d  ", str_tmp[j]);
    }
    printf("\n");
    return i;
}

void main()
{   
    int i=mon_log("%s,%d,%d,%c","abcdefghij",2,3,'\n');  //绿色高亮部分代码  
    printf("%d\n",i);
}
```



熟能生巧、事半功倍、减少返工



专题——平台相关的函数使用

专题——配对使用函数

专题——内存分配与释放

专题——安全使用函数

专题——格式化输入输出控制

专题——指针

专题——