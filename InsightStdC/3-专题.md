###  深入C库函数



推荐书籍


不要求写出统一风格的代码，只要求完全掌控自己写的代码




平台相关



memcpy

防止两个问题：

1、防止拷贝的长度溢出

2、防止没有正常结束符，从而导致溢出

方法一：字符数组初始化置0  或者 动态内存malloc分配后memset置0（calloc）

方法二：memcpy拷贝后，在最后一个字符后面置0





几种使用场景

一、固定分配buf，拷贝多少由buf与源字符串一起决定，缺点是容易造成拷贝截断

(strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str)



二、根据源字符串的大小来分配buf，长度由源字符串的长度来决定，缺点是容易无限制的拷贝



总结：不管怎样，对拷贝字符串的长度都应该作出限制！不可能无限制



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TEST_2
	
int main(void)
{
	#define BUF_LEN 200

#ifndef TEST_2
	
	printf("test method 1\n");
    char buf[BUF_LEN] = {0};//注意初始化，避免最后需要操作最后一个字符
	
#else
	
	printf("test method 2\n");
	char *buf = (char *)malloc(BUF_LEN * sizeof(char));
	if(!buf)
		return 0;
	
	memset(buf, 0, BUF_LEN);
	
#endif
	
	char *src_str = "1234567890";
  
	memcpy(buf, src_str, (strlen(src_str) > BUF_LEN) ? (BUF_LEN - 1) : strlen(src_str));
	
	printf("%s\n",buf);

#ifdef TEST_2

	free(buf);
	buf = NULL;
	
#endif
	
    return 0;
}
```



malloc与free





sscanf



_vsnprintf

常用于输入参数变长的打印函数





熟能生巧、事半功倍、减少返工



专题——平台相关的函数使用
sizeof
char
unsigned int
long


专题——配对使用函数
malloc与free
open与close


专题——内存分配与释放
malloc与free
malloc、calloc、realloc

专题——安全使用函数
sprintf与snprintf
strcpy与strncpy

专题——格式化输入输出控制
scanf
printf

专题——指针
C语言的精髓是指针

专题——assert的使用
debug版本
release版本