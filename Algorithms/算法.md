# 数据结构

数组、链表、队列、栈、树、图

# 算法

## 基础算法

随机化

水塘抽样

### 排序

https://mp.weixin.qq.com/s/mq2NSG3xMqIs28nU354TjQ

冒泡、选择、插入、希尔、归并、堆、快速、基数、桶、基数

![img](C:\Users\DELL\Desktop\zjb\算法\排序\排序算法比较.jpg)

#### 冒泡排序

把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….

我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。

除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。

```c
public static int[] bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return arr;
    }
    int n = arr.length;
    for (int i = 0; i < n; i++) {
        boolean flag = true;//利用标志改进
        for (int j = 0; j < n -i - 1; j++) {
            if (arr[j + 1] < arr[j]) {
                flag = false;//利用标志位改进
                int t = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = t;
            }
        }
        //一趟下来是否发生位置交换
        if(flag)
            break;
    }
    return arr;
}
```



![img](排序\冒泡排序.gif)



#### 选择排序

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为**选择排序**。

```c
public static int[] selectSort(int[] a) {
    int n = a.length;
    for (int i = 0; i < n - 1; i++) {
    	int min = i;
    	for (int j = i + 1; j < n; j++) {
    	if(a[min] > a[j]) min = j;
    	}
    	//交换
        int temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }
    return a;
}
```

![img](排序\选择排序.gif)

#### 插入排序

1、从数组第2个元素开始抽取元素。

2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。

3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。

![img](排序\插入排序.gif)

```c
public static int[] insertSort(int[] arr) {
    if(arr == null || arr.length < 2)
    	return arr;

    int n = arr.length;
    for (int i = 1; i < n; i++) {
    	int temp = arr[i];
    	int k = i - 1;
    	while(k >= 0 && arr[k] > temp)
    		k--;
    	//腾出位置插进去,要插的位置是 k + 1;
    	for(int j = i ; j > k + 1; j--)
    		arr[j] = arr[j-1];
    	//插进去
    	arr[k+1] = temp;
    }
    return arr;
}
```



#### 希尔排序

希尔排序可以说是**插入排序**的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。

希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。

希尔排序的思想是采用**插入排序**的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。

![img](排序\希尔排序.jpg)

```c

public static int[] shellSort(int arr[]) {
	if (arr == null || arr.length < 2) return arr;
	int n = arr.length;
	// 对每组间隔为 h的分组进行排序，刚开始 h = n / 2;
	for (int h = n / 2; h > 0; h /= 2) {
	//对各个局部分组进行插入排序
		for (int i = h; i < n; i++) {
			// 将arr[i] 插入到所在分组的正确位置上
			insertI(arr, h, i);
		}
	}
	return arr;
}

/**
* 将arr[i]插入到所在分组的正确位置上
* arr[i]] 所在的分组为 ... arr[i-2*h],arr[i-h], arr[i+h] ...
*/
private static void insertI(int[] arr, int h, int i) {
	int temp = arr[i];
	int k;
	for (k = i - h; k > 0 && temp < arr[k]; k -= h) {
		arr[k + h] = arr[k];
	}
	arr[k + h] = temp;
}

```



#### 归并排序

将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。

通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。

![img](排序\归并排序.gif)

```c
//递归式
public class MergeSort {
    // 归并排序
    public static int[] mergeSort(int[] arr, int left, int right) {
        // 如果 left == right，表示数组只有一个元素，则不用递归排序
        if (left < right) {
            // 把大的数组分隔成两个数组
            int mid = (left + right) / 2;
            // 对左半部分进行排序
            arr = mergeSort(arr, left, mid);
            // 对右半部分进行排序
            arr = mergeSort(arr, mid + 1, right);
            //进行合并
            merge(arr, left, mid, right);
        }
        return arr;
    }

    // 合并函数，把两个有序的数组合并起来
    // arr[left..mif]表示一个数组，arr[mid+1 .. right]表示一个数组
    private static void merge(int[] arr, int left, int mid, int right) {
        //先用一个临时数组把他们合并汇总起来
        int[] a = new int[right - left + 1];//非原地排序！
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                a[k++] = arr[i++];
            } else {
                a[k++] = arr[j++];
            }
        }
        while(i <= mid) a[k++] = arr[i++];
        while(j <= right) a[k++] = arr[j++];
        // 把临时数组复制到原数组
        for (i = 0; i < k; i++) {
            arr[left++] = a[i];
        }
    }
}

//非递归式
public class MergeSort {
    // 非递归式的归并排序
    public static int[] mergeSort(int[] arr) {
        int n = arr.length;
        // 子数组的大小分别为1，2，4，8...
        // 刚开始合并的数组大小是1，接着是2，接着4....
        for (int i = 1; i < n; i += i) {
            //进行数组进行划分
            int left = 0;
            int mid = left + i - 1;
            int right = mid + i;
            //进行合并，对数组大小为 i 的数组进行两两合并
            while (right < n) {
                // 合并函数和递归式的合并函数一样
                merge(arr, left, mid, right);
                left = right + 1;
                mid = left + i - 1;
                right = mid + i;
            }
            // 还有一些被遗漏的数组没合并，千万别忘了
            // 因为不可能每个字数组的大小都刚好为 i
            if (left < n && mid < n) {
                merge(arr, left, mid, n - 1);
            }
        }
        return arr;
    }
}
```

#### 快速排序

我们从数组中选择一个元素，我们把这个元素称之为**中轴元素**吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是**有序的**。也就是说，我们无需再移动中轴元素的位置。

从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于**有序的位置**。

![img](排序\快速排序.gif)

```c
public class QuickSort {
    public static int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            //获取中轴元素所处的位置
            int mid = partition(arr, left, right);
            //进行分割
            arr = quickSort(arr, left, mid - 1);
            arr = quickSort(arr, mid + 1, right);
        }
        return arr;
    }

    private static int partition(int[] arr, int left, int right) {
        //选取中轴元素
        int pivot = arr[left];
        int i = left + 1;
        int j = right;
        while (true) {
            // 向右找到第一个小于等于 pivot 的元素位置
            while (i <= j && arr[i] <= pivot) i++;
            // 向左找到第一个大于等于 pivot 的元素位置
            while(i <= j && arr[j] >= pivot ) j--;
            if(i >= j)
                break;
            //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        arr[left] = arr[j];
        // 使中轴元素处于有序的位置
        arr[j] = pivot;
        return j;
    }
}
```

#### 堆排序

堆的特点就是堆顶的元素是一个**最值**，大顶堆的堆顶是最大值，小顶堆则是最小值。

堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。

![img](排序\堆排序.gif)

```c
public class Head {
    // 堆排序
    public static int[] headSort(int[] arr) {
        int n = arr.length;
        //构建大顶堆
        for (int i = (n - 2) / 2; i >= 0; i--) {
            downAdjust(arr, i, n - 1);
        }
        //进行堆排序
        for (int i = n - 1; i >= 1; i--) {
            // 把堆顶元素与最后一个元素交换
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            // 把打乱的堆进行调整，恢复堆的特性
            downAdjust(arr, 0, i - 1);
        }
        return arr;
    }

        //下沉操作
    public static void downAdjust(int[] arr, int parent, int n) {
        //临时保存要下沉的元素
        int temp = arr[parent];
        //定位左孩子节点的位置
        int child = 2 * parent + 1;
        //开始下沉
        while (child <= n) {
            // 如果右孩子节点比左孩子大，则定位到右孩子
            if(child + 1 <= n && arr[child] < arr[child + 1])
                child++;
            // 如果孩子节点小于或等于父节点，则下沉结束
            if (arr[child] <= temp ) break;
            // 父节点进行下沉
            arr[parent] = arr[child];
            parent = child;
            child = 2 * parent + 1;
        }
        arr[parent] = temp;
    }
}
```

#### 计数排序

计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。

基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。

扩展：数字图像直方图

![img](排序\计数排序.gif)

```c
public class Counting {
    public static int[] sort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int min = arr[0];
        int max = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i < n; i++) {
            if(max < arr[i])
                max = arr[i];
            if(min > arr[i])
                min = arr[i];
        }
        int d = max - min + 1;
        //创建大小为d的临时数组
        int[] temp = new int[d];
        //统计元素i出现的次数
        for (int i = 0; i < n; i++) {
            temp[arr[i] - min]++;
        }
        int k = 0;
        //把临时数组统计好的数据汇总到原数组
        for (int i = 0; i < d; i++) {
            for (int j = temp[i]; j > 0; j--) {
                arr[k++] = i + min;
            }
        }
        return arr;
    }
}
```

#### 桶排序

桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。

之后每个桶里面的数据就是有序的了，我们在进行合并汇总。

![img](排序\桶排序.jpg)

```c
public class BucketSort {
    public static int[] BucketSort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int max = arr[0];
        int min = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i < n; i++) {
            if(min > arr[i])
                min = arr[i];
            if(max < arr[i])
                max = arr[i];
        }
        //和优化版本的计数排序一样，弄一个大小为 min 的偏移值
        int d = max - min;
        //创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数
        int bucketNum = d / 5 + 1;
        ArrayList<LinkedList<Integer>> bucketList = new ArrayList<>(bucketNum);
        //初始化桶
        for (int i = 0; i < bucketNum; i++) {
            bucketList.add(new LinkedList<Integer>());
        }
        //遍历原数组，将每个元素放入桶中
        for (int i = 0; i < n; i++) {
            bucketList.get((arr[i]-min)/d).add(arr[i] - min);
        }
        //对桶内的元素进行排序，我这里采用系统自带的排序工具
        for (int i = 0; i < bucketNum; i++) {
            Collections.sort(bucketList.get(i));
        }
        //把每个桶排序好的数据进行合并汇总放回原数组
        int k = 0;
        for (int i = 0; i < bucketNum; i++) {
            for (Integer t : bucketList.get(i)) {
                arr[k++] = t + min;
            }
        }
        return arr;
    }
}
```



#### 基数排序

基数排序的排序思路：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。

由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了

![img](排序\基数排序.gif)

```c
public class RadioSort {
    public static int[] radioSort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int max = arr[0];
        // 找出最大值
        for (int i = 1; i < n; i++) {
            if(max < arr[i]) max = arr[i];
        }
        // 计算最大值是几位数
        int num = 1;
        while (max / 10 > 0) {
            num++;
            max = max / 10;
        }
        // 创建10个桶
        ArrayList<LinkedList<Integer>> bucketList = new ArrayList<>(10);
        //初始化桶
        for (int i = 0; i < 10; i++) {
            bucketList.add(new LinkedList<Integer>());
        }
        // 进行每一趟的排序，从个位数开始排
        for (int i = 1; i <= num; i++) {
            for (int j = 0; j < n; j++) {
                // 获取每个数最后第 i 位是数组
                int radio = (arr[j] / (int)Math.pow(10,i-1)) % 10;
                //放进对应的桶里
                bucketList.get(radio).add(arr[j]);
            }
            //合并放回原数组
            int k = 0;
            for (int j = 0; j < 10; j++) {
                for (Integer t : bucketList.get(j)) {
                    arr[k++] = t;
                }
                //取出来合并了之后把桶清光数据
                bucketList.get(j).clear();
            }
        }
        return arr;
    }
}
```



### 字符串匹配

BF RK BM KMP

BF、BM、Horspool、Sunday、KMP、RK、AC自动机-多模式串匹配



#### Karp-Rabin（KR）算法

Karp-Rabin算法是利用hash函数的特性进行字符串匹配的。 KR算法对模式串和循环中每一次要匹配的子串按一定的hash函数求值，如果hash值相同，才进一步比较这两个串是否真正相等。

Karp-Rabin算法适用于多个字符串匹配较好。实际应用于检测抄袭。

```c
#include <stdio.h>  
#include <math.h>  
#include <assert.h>  
#include <string.h>  
#include <stdlib.h>
#include <time.h>
#define d 256 
#define PRIME 127 
#define MULTIPLER 0x015A4E35L
#define INCREMENT 1
int  seed;
void random_seed(int b)
{
	if(b==0)
	seed=time(0);
	else
	seed=b;
}
int random(int low,int high)
{
	seed=MULTIPLER*seed+INCREMENT;
	return ((seed>>16)%(high-low)+low);
} 
void RABIN_KARP_MATCHER(char *T,char*P)  
{   
    
    int M = strlen( P );  
    int N = strlen( T );
    /**********此处计算小于r的素数的集合R[]，以及集合中的元素个数K*************/
    int R[1000]; 
    int  k=2,i,j,flag,r;
     R[0]=2,R[1]=3;
     flag=0;
     r=12*M*N*N;
     for(i=2;i<r;i++) //判断小于r的素数存放于数组R[],并以k记录数组的个数 
     { 
          for(j=2;j<=sqrt(i);j++)//判断一个数是否为素数 
          {
          	   if(i%j!=0)
          	     {
				    flag=1;
				    continue;
          	     }
          	   else 
          	   {  flag=0;
          	   	   break;
          	   }
          }
          if(flag==1)
          {
          	  R[k]=i;
          	  k++;
          }  
     }
	int q;
	random_seed(0);
	q=random(1,k);//随机抽取k个素数中的其中一个 
	q=R[q];//获取R下表为q的的素数 
	/******此处开始模式匹配*********/
   assert(T&&P&&q >0 ); 
    int p = 0;//pat的哈希值 
    int t = 0;//txt的哈希值 
    int h = 1;             
    for(i=0;i < M - 1; i++)  
        h = (h*d)% q;   
    for( i = 0; i < M; i++ )  
    {  
        p = ( d * p + P[i] ) % q;  
        t = ( d * t + T[i] ) % q;  
    }  
      
    for( i = 0; i <= N - M; i++)  
    {  
        if( p == t)  
        {  
            for( j = 0; j < M; j++)  
                if(T[i+j] != P[j])  
                 break;  
            if( j == M )  
                printf("匹配串的起始位置为: %d\n", i+1);  
        }  
//计算移动窗口 
        if( i< N - M )  
        {  
            t = ( d * ( t - T[i] * h ) + T[i + M] ) % q;  
            if( t < 0 )  
                t+=q; 
        }  
    }  
}     
  
int main(int argc, char* argv[])  
{   char txt[1000],pat[1000];
    printf("请输入字符串：\n");
     gets(txt);
     printf("请输入所要匹配的模式串：\n");
     gets(pat);
    RABIN_KARP_MATCHER(txt,pat);        
    return 0;  
} 

————————————————
版权声明：本文为CSDN博主「重重姒姒」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_26365019/article/details/45980439
```



## 算法题

leetcode力扣 https://leetcode-cn.com/

牛客网https://www.nowcoder.com/

微信公众号：小浩算法、算法与数据结构、程序员面试、帅地玩编程





数组类（原位操作）



链表类

https://mp.weixin.qq.com/s/gchs1UI5XHgVP0_MtNSF9Q

博弈论



动态规划



滑动窗口



二叉树



### 摩尔投票法——俄罗斯方块消除法-动态规划

找出数组中出现次数大于n/m的元素

分析：在任何数组中，出现次数大于该数组长度n/m的值**只能有m-1个**（极限时为m个）

初始化m个容器（-1，计数为0）；遍历数组，当有空的容器时，记录该元素数值，计数加一；当没有空容器时，所有的容器计数同时减一；出现空容器时，原容器中的元素数值清空（-1），可记录其他元素数值。

```c
#include<stdio.h>
typedef struct Container_t
{
    int elem;
    int count;
} Container;

int majorityElement(int nums[], int len, int k)
{
    Container con[3]={{-1,0},{-1,0},{-1,0}};
    
    int flag= 0;
    
    for(int i=0; i<len; i++)
    {
        int exist=0;
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == nums[i])
            {
                con[j].count++;
                exist=1;
                break;
            } 
        }

        if(exist == 1)
            continue;
        
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == -1)
            {
                con[j].elem = nums[i];
                con[j].count++;
                break;
            }
        }
        
        int flag = 1;//do sub
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == -1)
            {
                flag = 0;
                break;
            } 
        }
        
        if(flag == 1)
        {
            for(int j=0; j<k; j++)
            {
                con[j].count--;
                if(con[j].count == 0)
                {
                    con[j].elem = -1;
                }
            }
        }
    }
    
    for(int j=0; j<k; j++)
    {
        if(con[j].elem != -1)
        { 
            // check if there is a majority
            int counter = 0;
            for(int i=0; i<len; i++)
            {
                if (nums[i] == con[j].elem) counter++;
            }
            
            if (counter > (len + 1) / k)
                printf("the major is %d\n",con[j].elem);
        }  
    }
    return 0; 
}

int main(int argc, char* argv[])
{
    int* out = NULL;
    int num[] = { 7,3,3,7,4,5,4,7,3,4,3,4,7,3,4 };
    //int num[] ={4,3,3,9,4,2,4,4,3,4,9,2};
    
    int len = sizeof(num)/sizeof(int);
    
    printf("len = %d\n", len);
    
    majorityElement(num, len, 3);

	return 0;
}

```



小球碰撞与圆周率的关系

https://www.zhihu.com/tardis/landing/360/ans/577232436?query=%E4%B8%96%E7%BA%AA%E9%9A%BE%E9%A2%98%E7%90%83%E4%B8%8E%E5%A2%99%E7%9A%84%E6%8E%A5%E8%A7%A6%E6%AC%A1%E6%95%B0%E6%98%AF%E5%9C%86%E5%91%A8%E7%8E%87&mid=052f3b5b63bfa021f1bfabaccd052fef&guid=8B86173C022D2E8E6CCD8F010AE788E4.1574503853295

http://www.360doc.com/content/19/0206/00/32901809_813272203.shtml

### Leetcode26：排序数组删除重复元素

| 题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次 |
| ------------------------------------------------------------ |
| 返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br/>示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。<br/>示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 |
| 注解：排序数组，原地删除要求不使用额外内存，C语言的实现有些链表快慢指针的味道 |

```c
#include <stdio.h>
int removeDuplicates(int nums[], int len)
{
    if (len == 0) return 0;
    //判断无输入
    int number = 0;//标记计数
    for (int i=0; i < len ; i++) {
        if ( nums[i] != nums[number] ) {
            number++;
            nums[number] = nums[i];
        }
    }
    number+=1; //标记+1即为数字个数
    
    for (int i=0; i < len ; i++) {
        printf("%d,", nums[i]);
    }
    return number;
}

int main(int argc, char* argv[])
{
    int num[] = {0,1,1,2,2,3,3,4};
    int len = sizeof(num)/sizeof(int);//数组在做实参时（作为指针）会丢失长度信息
    printf("num=%d", removeDuplicates(num, len));

	return 0;
}
```



### Leetcode27：原地移除数组中的制定元素

| 题目描述：给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 |
| ------------------------------------------------------------ |
| 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br/>示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素 |
| 注解：原地删除要求不使用额外内存，同上，C语言的实现有些链表快慢指针的味道；元素顺序可以改变 |

 

```c
#include <stdio.h>
//方法一-“快慢指针”
int removeElement(int nums[], int len, int val)
{
    int j = 0;
    for( int i = 0 ; i < len ; i ++ )
        if( nums[i] != val )
            nums[j++] = nums[i];
            
    for (int i=0; i < len ; i++) {
        printf("%d,", nums[i]);
    }
    return j;
}
//方法二-利用数组元素交换实现，较前者减少元素移动赋值次数
int removeElement2(int nums[], int len, int val)
{
    int j = len;
    int i = 0;
    while( i < j )
        if( nums[i] == val )
            nums[i] = nums[--j];
        else
            i ++;
            
    for (int i=0; i < len ; i++) {
        printf("%d,", nums[i]);
    }
    return j;
}

int main(int argc, char* argv[])
{
    int num[] = {3,2,2,3};
    int len = sizeof(num)/sizeof(int);
    printf("num=%d", removeElement(num, len, 3));

	return 0;
}
```

 

### LeetCode66：数组元素加1

| 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 |
| ------------------------------------------------------------ |
| 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br/>示例 1:<br/>输入: [1,2,3]<br/>输出: [1,2,4]<br/>解释: 输入数组表示数字 123。<br/><br/>示例 2:<br/>输入: [4,3,2,1]<br/>输出: [4,3,2,2]<br/>解释: 输入数组表示数字 4321。 |
| 考虑到两种情况：<br/>1、普通情况，除9之外的数字加1。<br/>2、特殊情况，9加1。（因为9加1需要进位） |
| 注解:全部是9的特殊情况，需要扩充数组；子函数中malloc分配内存与返回，主函数中释放 |

```c
#include <stdio.h>
#include <stdlib.h>

int plusOne(int digits[], int len, int **out_p)
{
    for(int i=len-1; i>=0; i--) 
    {
        if (digits[i] < 9)
        { // 当前位置不用进位，+1，然后直接返回
            digits[i]=digits[i]+1;
            *out_p = digits;
            return len;
        } else 
        { // 要进位，当前位置置0
            digits[i] = 0;
        }
    }  

    *out_p=(int *)calloc(len+1, sizeof(int));
    if(*out_p == NULL)
        return 0;

    (*out_p)[0] = 1;
    
    return len+1;
}

int main(int argc, char* argv[])
{
    int* out = NULL;
    int num[] = {6,9,9};
    printf("%p\n", num);
    int len = sizeof(num)/sizeof(int);
    int newlen = plusOne(num, len, &out);

    for (int i=0; i < newlen ; i++) {
        printf("%d,", out[i]);
    }
    printf("%p\n", out);
    if(newlen != len){
        free(out);
        out = NULL;
    }
	return 0;
}
```



### LeetCode283：移动数组中的零元素到末尾

| 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 |
| ------------------------------------------------------------ |
| 示例:<br/>输入: [0,1,0,3,12]<br/>输出: [1,3,12,0,0]<br/>说明:<br/>必须在原数组上操作，不能拷贝额外的数组。<br/>尽量减少操作次数。 |
| 注解：双指针，不改变非零元素相对顺序                         |

```c
#include <stdio.h>

void moveZeroes(int nums[], int len)
{
    int tmp;
    //快指针遇到非0元素就与慢指针所指的元素交换，最后快指针与慢指针之间的元素都为0
    for(int slow=0,i=0;i<len;++i)
        if(nums[i]!=0 && (slow!=i))//略过以非零元素开始的交换
        {
            tmp=nums[i];
            nums[i]=nums[slow];
            nums[slow]=tmp;
            slow++;
        }    
            
    for (int i=0; i < len ; i++) {
        printf("%d,", nums[i]);
    }
}

int main(int argc, char* argv[])
{
    int num[] = {0,0,2,3};
    int len = sizeof(num)/sizeof(int);
    moveZeroes(num, len);

	return 0;
}
```



### Leetcode299猜数字

| 猜数字（Bulls and Cows）游戏，你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。 |
| ------------------------------------------------------------ |
| 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。请注意秘密数字和朋友的猜测数都可能含有重复数字。<br/><br/>示例 1:<br/>输入: secret = "1807", guess = "7810"<br/>输出: "1A3B"<br/>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br/><br/>示例 2:<br/>输入: secret = "1123", guess = "0111"<br/>输出: "1A1B"<br/>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。<br/><br/>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 |
| 注解：使用hashmap；对于纯数字（范围确定且数量少），可以使用索引数组进行映射 |
|                                                              |

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define min(a,b) ((a)<(b)?(a):(b))

char *getHint(char *secret, char *guess, int len)
{
    char * name = NULL;
    name = (char *)malloc(4+1);
    
    int a = 0;
    int b = 0; 
    int mapS[10] = {0};
    int mapG[10] = {0};
    
    for(int i=0; i<len; i++)
    {
        if(secret[i] == guess[i])
            a++;
        else
        {
            mapS[secret[i]-'0']++;
            mapG[guess[i]-'0']++;
        }
    }
    for(int i=0; i<10; i++)
    {
        b += min(mapS[i], mapG[i]);
    }
    
    snprintf(name, 5, "%dA%dB", a, b);
    return name;
}

int main(int argc, char* argv[])
{
    char secret[] = "1807";
    char guess[] = "7810";
    
    char *result = NULL;
    result = getHint(secret, guess, strlen(secret));
    printf("the result is %s\n", result);
    
    free(result);
    result=NULL;
	return 0;
}
```



### Leetcode136 Single Number

| 题目描述<br/>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。 |
| ------------------------------------------------------------ |
| 注意：<br/>你需要给出一个**线性时间复杂度**的算法，你能在不使用额外内存空间的情况下解决这个问题么？ |

```java
class Solution {
    public int singleNumber(int[] nums) {
        int once = 0;
        for(int i = 0; i < nums.length; i++){
            once = once ^ nums[i];
        }
        return once ;
        }
    }
```



### Leetcode136 Single Number II

| 题目描述<br/>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现N次。 |
| ------------------------------------------------------------ |
| 注意：<br/>你需要给出一个**线性时间复杂度**的算法，你能在不使用额外内存空间的情况下解决这个问题么？ |

```java
//解法一——统计bit，普适于N次出现
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int bitNum[32]={0};
        int res=0,len=nums.size();
        for(int i=0;i<32;i++){
            for(int j=0;j<len;j++){
                bitNum[i] +=(nums[j]>>i)&1;
            }
            res |= (bitNum[i]%3)<<i; //通用框架，3可以换成k
        }
        return res;
    }
};

//解法二——三进制，N=3
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ones = 0;
        int twos = 0;
        int threes;
        for (int i=0; i<n;i++){
            int t = A[i];
            twos |= ones&t;
            ones ^= t;
            threes = ones & twos; //默认threes是0;
            ones &= ~threes;
            twos &= ~threes;
        }
        return ones;
    }
};
```







## C语言：函数返回字符串

1、 将字符串指针作为函数参数传入，并返回该指针。

典型的strcpy()函数应该就是采用的这种方法，第一个参数为指向目的字符串的指针,返回值也为这个指针。

内存空间在主函数中分配与释放

```c
char* strcpy(char* des,const char* source)
{
 char* r=des;
  assert((des != NULL) && (source != NULL));
　while((*r++ = *source++)!='\0');
　return des;
}
```

2、 使用malloc函数动态分配内存，注意在主调函数中释放。（堆区内存，需手动释放回收）

内存空间在子函数中分配，在主函数中释放

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//方法一 直接返回指针
char * retstring()
{
    char * name;
    name = (char *)malloc(10); 
    strcpy(name,"张汉青");
    return name;
}
//方法二 使用双重指针
int retstring2(char **ptr)
{
    *ptr = (char *)malloc(10); 
    strcpy(*ptr,"张汉青2");
    
    return 0;
}

int main()
{
    char * name2 = NULL;
    name2 = retstring();
    printf("%s\n",name2);
    //记住一定要用free释放，否则会造成内存泄露
    free(name2);
    name2 = NULL;
    
    retstring2(&name2);
    printf("%s\n",name2);
    //记住一定要用free释放，否则会造成内存泄露
    free(name2);
    name2 = NULL;
    return 0;
}
```

3、 返回一个静态局部变量。（不推荐）

这种方法有一个问题： 由于采用了静态局部变量（位于静态区，程序结束时由系统进行释放），这就导致，如果多次调用这个函数，**下一次调用会将上一次调用的结果覆盖掉。**

C语言中的库函数，tmpnam()函数、getenv()函数等应该都是采用的这种方法，这也就是为什么，使用这样的函数的时候应该立即将返回结果拷贝一份的原因。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char * retstring();
int main()
{
    char * name2;
    name2 = retstring();
    printf("%s\n",name2);
    return 0;
}

char * retstring()
{
    static char name[10];
    strcpy(name,"张汉青");
    return name;
}
```

4、 使用全局变量。（不推荐）

```c
char   g_s[100]; 
char*   fun() 
{ 
        strcpy(g_s,   "abc "); 
        return   g_s; 
} 
```



### snprintf

自从snprintf代替了sprintf，相信大家对snprintf的使用都不会少，函数定义如下：

**int snprintf(char*str, size_t size,constchar*format, ...);**

函数说明:

最多从源串中拷贝**（size－1）**个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为size的话，将不会溢出。

函数返回值:

若成功则返回**欲写入**的字符串长度（非实际写入），若出错则返回负值。

### strncpy



## C/C++刁钻问题各个击破之细说sizeof

Sizeof的作用非常简单：求对象或者类型的大小。然而sizeof又非常复杂，它涉及到很多特殊情况，本篇把这些情况分门别类，总结出了sizeof的10个特性：

(0)sizeof是运算符，不是函数；

(1)sizeof不能求得void类型的长度；

(2)sizeof能求得void类型的指针的长度；

(3)sizeof能求得静态分配内存的数组的长度!

**(4)sizeof不能求得动态分配的内存的大小!**

(5)sizeof不能对不完整的数组求长度；

(6)当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！

(7)sizeof可以对函数调用求大小，并且求得的大小等于返回类型的大小，但是不执行函数体！

(8)sizeof求得的结构体(及其对象)的大小并不等于各个数据成员对象的大小之和！

(9)sizeof不能用于求结构体的位域成员的大小，但是可以求得包含位域成员的结构体的大小！