# 数据结构

数组、链表、队列、栈、树、图

# 算法

## 基础算法

随机化

水塘抽样

### 排序

https://mp.weixin.qq.com/s/mq2NSG3xMqIs28nU354TjQ

冒泡、选择、插入、希尔、归并、堆、快速、基数、桶、基数

![img](排序\排序算法比较.jpg)

#### 冒泡排序

把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….

我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。

除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。

```c
public static int[] bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return arr;
    }
    int n = arr.length;
    for (int i = 0; i < n; i++) {
        boolean flag = true;//利用标志改进
        for (int j = 0; j < n -i - 1; j++) {
            if (arr[j + 1] < arr[j]) {
                flag = false;//利用标志位改进
                int t = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = t;
            }
        }
        //一趟下来是否发生位置交换
        if(flag)
            break;
    }
    return arr;
}
```



![img](排序\冒泡排序.gif)



#### 选择排序

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为**选择排序**。

```c
public static int[] selectSort(int[] a) {
    int n = a.length;
    for (int i = 0; i < n - 1; i++) {
    	int min = i;
    	for (int j = i + 1; j < n; j++) {
    	if(a[min] > a[j]) min = j;
    	}
    	//交换
        int temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }
    return a;
}
```

![img](排序\选择排序.gif)

#### 插入排序

1、从数组第2个元素开始抽取元素。

2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。

3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。

![img](排序\插入排序.gif)

```c
public static int[] insertSort(int[] arr) {
    if(arr == null || arr.length < 2)
    	return arr;

    int n = arr.length;
    for (int i = 1; i < n; i++) {
    	int temp = arr[i];
    	int k = i - 1;
    	while(k >= 0 && arr[k] > temp)
    		k--;
    	//腾出位置插进去,要插的位置是 k + 1;
    	for(int j = i ; j > k + 1; j--)
    		arr[j] = arr[j-1];
    	//插进去
    	arr[k+1] = temp;
    }
    return arr;
}
```



#### 希尔排序

希尔排序可以说是**插入排序**的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。

希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。

希尔排序的思想是采用**插入排序**的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。

![img](排序\希尔排序.jpg)

```c

public static int[] shellSort(int arr[]) {
	if (arr == null || arr.length < 2) return arr;
	int n = arr.length;
	// 对每组间隔为 h的分组进行排序，刚开始 h = n / 2;
	for (int h = n / 2; h > 0; h /= 2) {
	//对各个局部分组进行插入排序
		for (int i = h; i < n; i++) {
			// 将arr[i] 插入到所在分组的正确位置上
			insertI(arr, h, i);
		}
	}
	return arr;
}

/**
* 将arr[i]插入到所在分组的正确位置上
* arr[i]] 所在的分组为 ... arr[i-2*h],arr[i-h], arr[i+h] ...
*/
private static void insertI(int[] arr, int h, int i) {
	int temp = arr[i];
	int k;
	for (k = i - h; k > 0 && temp < arr[k]; k -= h) {
		arr[k + h] = arr[k];
	}
	arr[k + h] = temp;
}

```



#### 归并排序

将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。

通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。

![img](排序\归并排序.gif)

```c
//递归式
public class MergeSort {
    // 归并排序
    public static int[] mergeSort(int[] arr, int left, int right) {
        // 如果 left == right，表示数组只有一个元素，则不用递归排序
        if (left < right) {
            // 把大的数组分隔成两个数组
            int mid = (left + right) / 2;
            // 对左半部分进行排序
            arr = mergeSort(arr, left, mid);
            // 对右半部分进行排序
            arr = mergeSort(arr, mid + 1, right);
            //进行合并
            merge(arr, left, mid, right);
        }
        return arr;
    }

    // 合并函数，把两个有序的数组合并起来
    // arr[left..mif]表示一个数组，arr[mid+1 .. right]表示一个数组
    private static void merge(int[] arr, int left, int mid, int right) {
        //先用一个临时数组把他们合并汇总起来
        int[] a = new int[right - left + 1];//非原地排序！
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                a[k++] = arr[i++];
            } else {
                a[k++] = arr[j++];
            }
        }
        while(i <= mid) a[k++] = arr[i++];
        while(j <= right) a[k++] = arr[j++];
        // 把临时数组复制到原数组
        for (i = 0; i < k; i++) {
            arr[left++] = a[i];
        }
    }
}

//非递归式
public class MergeSort {
    // 非递归式的归并排序
    public static int[] mergeSort(int[] arr) {
        int n = arr.length;
        // 子数组的大小分别为1，2，4，8...
        // 刚开始合并的数组大小是1，接着是2，接着4....
        for (int i = 1; i < n; i += i) {
            //进行数组进行划分
            int left = 0;
            int mid = left + i - 1;
            int right = mid + i;
            //进行合并，对数组大小为 i 的数组进行两两合并
            while (right < n) {
                // 合并函数和递归式的合并函数一样
                merge(arr, left, mid, right);
                left = right + 1;
                mid = left + i - 1;
                right = mid + i;
            }
            // 还有一些被遗漏的数组没合并，千万别忘了
            // 因为不可能每个字数组的大小都刚好为 i
            if (left < n && mid < n) {
                merge(arr, left, mid, n - 1);
            }
        }
        return arr;
    }
}
```

#### 快速排序

我们从数组中选择一个元素，我们把这个元素称之为**中轴元素**吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是**有序的**。也就是说，我们无需再移动中轴元素的位置。

从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于**有序的位置**。

![img](排序\快速排序.gif)

```c
public class QuickSort {
    public static int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            //获取中轴元素所处的位置
            int mid = partition(arr, left, right);
            //进行分割
            arr = quickSort(arr, left, mid - 1);
            arr = quickSort(arr, mid + 1, right);
        }
        return arr;
    }

    private static int partition(int[] arr, int left, int right) {
        //选取中轴元素
        int pivot = arr[left];
        int i = left + 1;
        int j = right;
        while (true) {
            // 向右找到第一个小于等于 pivot 的元素位置
            while (i <= j && arr[i] <= pivot) i++;
            // 向左找到第一个大于等于 pivot 的元素位置
            while(i <= j && arr[j] >= pivot ) j--;
            if(i >= j)
                break;
            //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        arr[left] = arr[j];
        // 使中轴元素处于有序的位置
        arr[j] = pivot;
        return j;
    }
}
```

#### 堆排序

堆的特点就是堆顶的元素是一个**最值**，大顶堆的堆顶是最大值，小顶堆则是最小值。

堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。

![img](排序\堆排序.gif)

```c
public class Head {
    // 堆排序
    public static int[] headSort(int[] arr) {
        int n = arr.length;
        //构建大顶堆
        for (int i = (n - 2) / 2; i >= 0; i--) {
            downAdjust(arr, i, n - 1);
        }
        //进行堆排序
        for (int i = n - 1; i >= 1; i--) {
            // 把堆顶元素与最后一个元素交换
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            // 把打乱的堆进行调整，恢复堆的特性
            downAdjust(arr, 0, i - 1);
        }
        return arr;
    }

        //下沉操作
    public static void downAdjust(int[] arr, int parent, int n) {
        //临时保存要下沉的元素
        int temp = arr[parent];
        //定位左孩子节点的位置
        int child = 2 * parent + 1;
        //开始下沉
        while (child <= n) {
            // 如果右孩子节点比左孩子大，则定位到右孩子
            if(child + 1 <= n && arr[child] < arr[child + 1])
                child++;
            // 如果孩子节点小于或等于父节点，则下沉结束
            if (arr[child] <= temp ) break;
            // 父节点进行下沉
            arr[parent] = arr[child];
            parent = child;
            child = 2 * parent + 1;
        }
        arr[parent] = temp;
    }
}
```

#### 计数排序

计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。

基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。

扩展：数字图像直方图

![img](排序\计数排序.gif)

```c
public class Counting {
    public static int[] sort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int min = arr[0];
        int max = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i < n; i++) {
            if(max < arr[i])
                max = arr[i];
            if(min > arr[i])
                min = arr[i];
        }
        int d = max - min + 1;
        //创建大小为d的临时数组
        int[] temp = new int[d];
        //统计元素i出现的次数
        for (int i = 0; i < n; i++) {
            temp[arr[i] - min]++;
        }
        int k = 0;
        //把临时数组统计好的数据汇总到原数组
        for (int i = 0; i < d; i++) {
            for (int j = temp[i]; j > 0; j--) {
                arr[k++] = i + min;
            }
        }
        return arr;
    }
}
```

#### 桶排序

桶排序就是把最大值和最小值之间的数进行瓜分，例如分成  10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。

之后每个桶里面的数据就是有序的了，我们在进行合并汇总。

![img](排序\桶排序.jpg)

```c
public class BucketSort {
    public static int[] BucketSort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int max = arr[0];
        int min = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i < n; i++) {
            if(min > arr[i])
                min = arr[i];
            if(max < arr[i])
                max = arr[i];
        }
        //和优化版本的计数排序一样，弄一个大小为 min 的偏移值
        int d = max - min;
        //创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数
        int bucketNum = d / 5 + 1;
        ArrayList<LinkedList<Integer>> bucketList = new ArrayList<>(bucketNum);
        //初始化桶
        for (int i = 0; i < bucketNum; i++) {
            bucketList.add(new LinkedList<Integer>());
        }
        //遍历原数组，将每个元素放入桶中
        for (int i = 0; i < n; i++) {
            bucketList.get((arr[i]-min)/d).add(arr[i] - min);
        }
        //对桶内的元素进行排序，我这里采用系统自带的排序工具
        for (int i = 0; i < bucketNum; i++) {
            Collections.sort(bucketList.get(i));
        }
        //把每个桶排序好的数据进行合并汇总放回原数组
        int k = 0;
        for (int i = 0; i < bucketNum; i++) {
            for (Integer t : bucketList.get(i)) {
                arr[k++] = t + min;
            }
        }
        return arr;
    }
}
```



#### 基数排序

基数排序的排序思路：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。

由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了

![img](排序\基数排序.gif)

```c
public class RadioSort {
    public static int[] radioSort(int[] arr) {
        if(arr == null || arr.length < 2) return arr;

        int n = arr.length;
        int max = arr[0];
        // 找出最大值
        for (int i = 1; i < n; i++) {
            if(max < arr[i]) max = arr[i];
        }
        // 计算最大值是几位数
        int num = 1;
        while (max / 10 > 0) {
            num++;
            max = max / 10;
        }
        // 创建10个桶
        ArrayList<LinkedList<Integer>> bucketList = new ArrayList<>(10);
        //初始化桶
        for (int i = 0; i < 10; i++) {
            bucketList.add(new LinkedList<Integer>());
        }
        // 进行每一趟的排序，从个位数开始排
        for (int i = 1; i <= num; i++) {
            for (int j = 0; j < n; j++) {
                // 获取每个数最后第 i 位是数组
                int radio = (arr[j] / (int)Math.pow(10,i-1)) % 10;
                //放进对应的桶里
                bucketList.get(radio).add(arr[j]);
            }
            //合并放回原数组
            int k = 0;
            for (int j = 0; j < 10; j++) {
                for (Integer t : bucketList.get(j)) {
                    arr[k++] = t;
                }
                //取出来合并了之后把桶清光数据
                bucketList.get(j).clear();
            }
        }
        return arr;
    }
}
```



### 字符串匹配

BF RK BM KMP

BF、BM、Horspool、Sunday、KMP、KR、AC自动机-多模式串匹配

解决字符串匹配的算法包括：朴素算法（Naive Algorithm）、Rabin-Karp 算法、有限自动机算法（Finite Automation）、 Knuth-Morris-Pratt 算法（即 KMP Algorithm）、Boyer-Moore 算法、Simon 算法、Colussi 算法、Galil-Giancarlo 算法、Apostolico-Crochemore 算法、Horspool 算法和 Sunday 算法等。

字符串匹配算法通常分为两个步骤：预处理（Preprocessing）和匹配（Matching）。所以算法的总运行时间为预处理和匹配的时间的总和。

字符串匹配问题的形式定义：

- **文本（Text）**是一个长度为 n 的数组 T[1..n]；
- **模式（Pattern）**是一个长度为 m 且 m≤n 的数组 P[1..m]；
- T 和 P 中的元素都属于有限的**字母表 Σ 表**；
- 如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个**有效位移（Valid Shift）**。

#### BF（Brute Force）算法

即暴力算法，穷举法，枚举法，也叫暴力匹配。是最低效最原始的算法。特点：

1. 无预处理阶段，不需要对文本（text）或模式串（pattern）进行预处理。（因为是暴力匹配）
2. 对Pattern，可以从T的首或尾开始逐个匹配字母，比较顺序没有限制。
3. 最坏时间复杂度O((n-m+1)m)=O(nm)。



#### KR（Karp-Rabin）算法

Karp-Rabin算法是利用hash函数的特性进行字符串匹配的。 KR算法对模式串和循环中每一次要匹配的子串按一定的hash函数求值，如果hash值相同，才进一步比较这两个串是否真正相等。

Rabin-Karp的复杂度理论上是O(nm)，但在实际使用中通常是O(n+m)。  需要注意的是Rabin-Karp算法需要O(m)的预处理时间。

事实上，由于哈希函数无法保证对不同的字符串产生不同的哈希值，有哈希冲突的现象存在，所以即使模式串的哈希值和文本子串的哈希值相等，也需要对这两个长度为m的字符串进行额外的比对（当然，如果不相等也就不用比对了，其实大部分的时间省在这上面），这时比对的开销是O(m)。最坏情况下，文本中所有长度为m的子串(一共n-m+1个)都和模式串匹配，所以算法复杂度为O((n-m+1)m)。然而实际情况下，需要进一步比对的子串个数总是有限的（假设为c个），那么算法的期望匹配时间就变成O((n-m+1)+cm)=O(n+m)。

Karp-Rabin算法适用于多模式匹配。实际应用于检测抄袭。

```c
#include <stdio.h>  
#include <math.h>  
#include <assert.h>  
#include <string.h>  
#include <stdlib.h>
#include <time.h>
#define d 256 
#define PRIME 127 
#define MULTIPLER 0x015A4E35L
#define INCREMENT 1
int  seed;
void random_seed(int b)
{
	if(b==0)
	seed=time(0);
	else
	seed=b;
}
int random(int low,int high)
{
	seed=MULTIPLER*seed+INCREMENT;
	return ((seed>>16)%(high-low)+low);
} 
void RABIN_KARP_MATCHER(char *T,char*P)  
{   
    
    int M = strlen( P );  
    int N = strlen( T );
    /**********此处计算小于r的素数的集合R[]，以及集合中的元素个数K*************/
    int R[1000]; 
    int  k=2,i,j,flag,r;
     R[0]=2,R[1]=3;
     flag=0;
     r=12*M*N*N;
     for(i=2;i<r;i++) //判断小于r的素数存放于数组R[],并以k记录数组的个数 
     { 
          for(j=2;j<=sqrt(i);j++)//判断一个数是否为素数 
          {
          	   if(i%j!=0)
          	     {
				    flag=1;
				    continue;
          	     }
          	   else 
          	   {  flag=0;
          	   	   break;
          	   }
          }
          if(flag==1)
          {
          	  R[k]=i;
          	  k++;
          }  
     }
	int q;
	random_seed(0);
	q=random(1,k);//随机抽取k个素数中的其中一个 
	q=R[q];//获取R下表为q的的素数 
	/******此处开始模式匹配*********/
   assert(T&&P&&q >0 ); 
    int p = 0;//pat的哈希值 
    int t = 0;//txt的哈希值 
    int h = 1;             
    for(i=0;i < M - 1; i++)  
        h = (h*d)% q;   
    for( i = 0; i < M; i++ )  
    {  
        p = ( d * p + P[i] ) % q;  
        t = ( d * t + T[i] ) % q;  
    }  
      
    for( i = 0; i <= N - M; i++)  
    {  
        if( p == t)  
        {  
            for( j = 0; j < M; j++)  
                if(T[i+j] != P[j])  
                 break;  
            if( j == M )  
                printf("匹配串的起始位置为: %d\n", i+1);  
        }  
//计算移动窗口 
        if( i< N - M )  
        {  
            t = ( d * ( t - T[i] * h ) + T[i + M] ) % q;  
            if( t < 0 )  
                t+=q; 
        }  
    }  
}     
  
int main(int argc, char* argv[])  
{   char txt[1000],pat[1000];
    printf("请输入字符串：\n");
     gets(txt);
     printf("请输入所要匹配的模式串：\n");
     gets(pat);
    RABIN_KARP_MATCHER(txt,pat);        
    return 0;  
} 

————————————————
版权声明：本文为CSDN博主「重重姒姒」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_26365019/article/details/45980439
```

```c
//Following program is a C implementation of the Rabin Karp Algorithm
//given in the CLRS book
#include <stdio.h>
#include <string.h>


//d is the number of characters in input alphabet
#define d 256

//pat -> pattern    txt -> text        q -> A prime number
void search(char *pat, char *txt, int q)
{
    int m = strlen(pat);
    int n = strlen(txt);

    int i, j;
    
    int p = 0;        //hash value for pattern
    int t = 0;        //hash value for txt
    int h = 1;

    //the value of h would be "pow(d, m - 1) % q"
    for(i = 0; i < m - 1; i++)
    {
        h = (h * d) % q;
    }

    //calculate the hash value of pattern and first window of text
    for(i = 0; i < m; i++)
    {
        p = (d * p + pat[i]) % q;
        t = (d * t + txt[i]) % q;
    }

    //slide the pattern over text one by one
    for(i = 0; i <= n - m; i++)
    {
        //check the hash values of current window of text and pattern
        //if the hash values match then only check for characters on by one
        if(p == t)
        {
            //check for characters one by one
            for(j = 0; j < m; j++)
            {
                if(txt[i + j] != pat[j])
                {
                    break;
                }
            }
            if(j == m)    //found
            {
                printf("Pattern found at index %d\n", i);
            }
        }
        //calulate hash value for next window of text: remove leading digit
        //add trailing digit
        if(i < n - m)
        {
            t = (d * ( t - txt[i] * h) + txt[i + m]) % q;

            //we might get negative value of t, converting it to positive
            if(t < 0)
            {
                t = t + q;
            }
        }
    }
}

int main()
{
    char *txt = "Geeks For Geeks";
    char *pat = "Geek";
    int q = 101;                    //A prime number
    search(pat, txt, q);
    getchar();
    return 0;
}

```



#### BM（Boyer-Moore） 算法-单模式匹配

各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法。



"坏字符规则"：

　　后移位数 = 坏字符的位置（文本中） - 搜索词中的上一次出现位置



"好后缀规则"：

　　后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置

这个规则有三个注意点：

　　（1）"好后缀"的位置以最后一个字符为准。假定"ABCDEF"的"EF"是好后缀，则它的位置以"F"为准，即5（从0开始计算）。

　　（2）如果"好后缀"在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，"EF"在"ABCDEF"之中只出现一次，则它的上一次出现位置为-1（即未出现）。

　　（3）如果"好后缀"有多个，则除了最长的那个"好后缀"，其他"好后缀"的上一次出现位置必须在头部。比如，假定"BABCDAB"的"好后缀"是"DAB"、"AB"、"B"，请问这时"好后缀"的上一次出现位置是什么？回答是，此时采用的好后缀是"B"，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个"好后缀"只出现一次，则可以把搜索词改写成如下形式进行位置计算"(DA)BABCDAB"，即虚拟加入最前面的"DA"。

**Boyer-Moore算法的基本思想是，每次后移这两个规则之中的较大值。**



#### Sunday算法

Sunday算法其实思想跟BM算法很相似，只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+ 1；否则，同BM算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。

```c
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
char a[10005],b[10005];//long a>long b
int c[30];//表示b串中存在的字母；不存在则为1，存在为最靠后的此字符距离尾部加一（要跳的地方） 
int la,lb;//字符串a,b的长度 
int head;//当前搜索到的头字符 
int main()
{
    scanf("%s",a);
    scanf("%s",b);//read in
    la=strlen(a);
    lb=strlen(b); 
    for(int i=0;i<=lb-1;i++)
        c[b[i]-'a'+1]=lb-i;//初始化c数组 
    for(int i=0;head<=la-1;)//i表示当前匹配长度 ,head指针跳到a尾时结束 
    {
        if(a[head+i]==b[i])
        {
            i++;//匹配则更新i值
            if(i==lb) //匹配到的长度等于b串长度 则成功 
            {
                printf("Yes");return 0;
            }
        }        
        else
        {
            if(c[a[head+lb]-'a'+1]!=0) head=head+c[a[head+lb]-'a'+1];//判断是否出现
            else head=head+lb+2; //未出现，跳到下一个长度 
            i=0;//匹配值更新为0
        }         
    }
    printf("No");
    return 0;
}
```



#### KMP （Knuth-Morris-Pratt） 算法-单模式匹配

KMP 算法的主要特点是：

1. 需要对模式字符串做预处理；
2. 预处理阶段需要额外的 O(m) 空间和复杂度；
3. 匹配阶段与字符集的大小无关；
4. 匹配阶段至多执行 2n - 1 次字符比较；
5. 对模式中字符的比较顺序时从左到右；



 KMP算法的核心是寻找模式串本身的规律。在该算法中表现为反映该规律的next数组。next数组的作用是在每次失配时，模式串根据next数组对应位置上的值回溯模式串索引的位置。next数组的求法也是KMP算法的精华所在。在本文的参考博文[1]和参考博文[2]中均给出了next数组的具体求法，但是遗憾的是在[1]中，并没有给出next数组的具体含义，而[2]中给出了具体的next定义。

   next数组有如下定义：

​    (1) next[j]=-1   j=0

   (2) next[j]=max ( k ):   0<k<j  P[0...k-1]=P[j-k,j-1]

​    (3) next[j]=0   其他

   该定义的意义就是next数组的首位均为-1。在其他位置上，该位置之前的子串中最长的相同前后缀长度（注释1）。当没有任何相同的前后缀的情况下，next值为0。



**next数组的计算方法**

   由next数组的定义可知，可以用一种递推的思想来求解next数组。

   根据定义next[0] = -1

   假设next[j] = k, 即P[0...k-1] == P[j-k,j-1]

   (1)若P[j] == P[k]，则有P[0..k]==P[j-k,j]，很显然，next[j+1]=next[j]+1=k+1;

   (2)若P[j] != P[k]，则可以把其看做模式匹配的问题，即匹配失败的时候，k值如何移动，显然k=next[k]。



##### 部分匹配表next

```c
/* 在计算“部分匹配表”时，一般使用DP（动态规划）算法来计算（表示为next数组） */
int* next = new int[needle.length()];
next[0] = 0;
int k = 0;
for (int i = 1; i < needle.length(); i++)
{
    while (k > 0 && needle[i] != needle[k])
    {
        k = next[k - 1];
    }
    if (needle[i] == needle[k])
    {
        k++;
    }
    next[i] = k;
}
```

```c
void get_next(const char* ptrn,int* nextval)
{
	int plen = strlen(ptrn);
 
	int i = 0;
	int k = -1;
	nextval[i] = -1;
 
	while(i < plen -1)
	{
		if (k == -1 || ptrn[i] == ptrn[k])
		{
			++i;
			++k;
			nextval[i] = k;
		}
		else
		{
			k = nextval[k];
		}
	}
}
int KMP_search(const char* src, const char* ptrn, const int *nextval )
{
	int i=0;
	int j=0;
	int slen = strlen(src);
	int plen = strlen(ptrn);
 
	while(i<slen && j<plen)
	{
		if (j == -1 || src[i] == ptrn[j])
		{
			i++;
			j++;
		}
		else
		{
			j = nextval[j];
		}
	}
 
	if ( j >= plen)
	{
		return i - plen;
	}
	else
	{
		return -1;
	}
}
```



#### AC算法-多模式匹配

多模式匹配AC算法的核心仍然是寻找模式串内部规律，达到在每次失配时的高效跳转。这一点与单模式匹配KMP算法和BM算法是一致的。不同的是，AC算法寻找的是模式串之间的相同前缀关系。AC算法的核心是三张查找表：goto、failure和output，共包含四种具体的算法，分别是计算三张查找表的算法以及AC算法本身。



在互联网应用中，通常会用到关键词检测功能，以防止用户发表包括了指定关键词的内容。如游戏的聊天系统、角色名称检测，论坛发帖、直播弹幕等，都需要对用户发布的内容进行检测，以检测是否包含敏感的关键字。

通常需要检测的关键词，会有很多很多，比如侮辱人的关键词，政治敏感的关键词，系统相关的特定关键词等。毫不夸张的说，通常要检测的关键词会有几千个，甚至过万。这时效率都变得尤为突出，如果检测关键词的效率低下，对大型互联网应用来说，很可能有是致命的。

以8000个关键词为例，如果使用正则表达式，则需要对用户发布的内容遍历8000遍。如果同一秒中，有100位，1000位，10000位...用户发布内容，可想而知仅仅在关键词检测方面服务器上CPU的开销。

AC多模式匹配算法，可以有效的解决关键词检测的效率问题。时间复杂度为O(n),n为用户发布内容的长度n。基本与关键词的数量无关。

AC算法是Alfred V.Aho（《编译原理》的作者），和Margaret J.Corasick于1974年提出（与KMP算法同年）的一个经典的多模式匹配算法，可以保证对于给定的长度为n的文本，和模式集合P{p1,p2,...pm}，在O(n)时间复杂度内，找到文本中的所有目标模式，而与模式集合的规模m无关。

AC算法实现原理，大体上可分为三步：
1）构建敏感词树型结构，并标注结束节点（即是否是一个敏感词的结束）；
2）为树上的结点，构建匹配失败时的跳转-失败结点（即匹配失败时，跳转到哪个结点继续匹配）；
3）对用户内容进行一次遍历，对于每个字符（字节）都去敏感词树型结构中，从当前结点位置开始匹配。
如果匹配成功，则当前结点，下移到对应的结点。如果当前结点为“结束节点”，则表示匹配成功；
如果匹配失败，则当前结点，跳转到该结点的失败结点，继续匹配，直到匹配成功或当前结点为根结点；

 

1）构建敏感词树型结构，并标注结束节点（即是否是一个敏感词的结束）
首先要有一个根结点；
遍历所有的敏感词，将每个敏感词的每一个字节，放到树上，成为一个结点。每一个字节的前一字节所对应的结点，都为该字节所对应结点的父结点。如果字节所对应的结点已存在，则不再添加新的结点。如果该字节为敏感词的最后一个字节，则将对应结点，设置为结束结点。

如敏感词：he,hers,his,erase


![img](http://dl2.iteye.com/upload/attachment/0130/6102/eed64dee-78a0-3e5d-a3d0-d58542d8d986.png)

 

2）为树上的结点，构建匹配失败时的跳转-失败结点（即匹配失败时，跳转到哪个结点继续匹配）
第一层子节点的失败节点，直接指定是根结点；
其它子节点的失败节点，是其父结点的失败点中查找相应的路径。如果查不到，则继续在当前结点的失败结点中查找相应的路径。直到找相应的节点，或失败节点为根结点。


![img](http://dl2.iteye.com/upload/attachment/0130/6100/44d8c184-b846-3351-bf93-d9daf88dc424.png)

 

3)对用户内容进行一次遍历，对于每个字符（字节）都去敏感词树型结构中，从当前结点位置开始匹配。
如果匹配成功，则当前结点，下移到对应的结点。如果当前结点为“结束节点”，则表示匹配成功；
如果匹配失败，则当前结点，跳转到该结点的失败结点，继续匹配，直到匹配成功或当前结点为根结点；

```c
#include <iostream> 
#include<cstdlib> 
#define MAX 26 
using namespace std; 
  
typedef struct TrieNode                     //Trie结点声明  
{ 
    bool isStr;                            //标记该结点处是否构成单词  
    struct TrieNode *next[MAX];            //儿子分支  
}Trie; 
  
void insert(Trie *root,const char *s)     //将单词s插入到字典树中  
{ 
    if(root==NULL||*s=='\0') 
        return; 
    int i; 
    Trie *p=root; 
    while(*s!='\0') 
    { 
        if(p->next[*s-'a']==NULL)        //如果不存在，则建立结点  
        { 
            Trie *temp=(Trie *)malloc(sizeof(Trie)); 
            for(i=0;i<MAX;i++) 
            { 
                temp->next[i]=NULL; 
            } 
            temp->isStr=false; 
            p->next[*s-'a']=temp; 
            p=p->next[*s-'a'];    
        }    
        else
        { 
            p=p->next[*s-'a']; 
        } 
        s++; 
    } 
    p->isStr=true;                       //单词结束的地方标记此处可以构成一个单词  
} 
  
int search(Trie *root,const char *s)  //查找某个单词是否已经存在  
{ 
    Trie *p=root; 
    while(p!=NULL&&*s!='\0') 
    { 
        p=p->next[*s-'a']; 
        s++; 
    } 
    return (p!=NULL&&p->isStr==true);      //在单词结束处的标记为true时，单词才存在  
} 
  
void del(Trie *root)                      //释放整个字典树占的堆区空间  
{ 
    int i; 
    for(i=0;i<MAX;i++) 
    { 
        if(root->next[i]!=NULL) 
        { 
            del(root->next[i]); 
        } 
    } 
    free(root); 
} 
  
int main(int argc, char *argv[]) 
{ 
    int i; 
    int n,m;                              //n为建立Trie树输入的单词数，m为要查找的单词数  
    char s[100]; 
    Trie *root= (Trie *)malloc(sizeof(Trie)); 
    for(i=0;i<MAX;i++) 
    { 
        root->next[i]=NULL; 
    } 
    root->isStr=false; 
    scanf("%d",&n); 
    getchar(); 
    for(i=0;i<n;i++)                 //先建立字典树  
    { 
        scanf("%s",s); 
        insert(root,s); 
    } 
    while(scanf("%d",&m)!=EOF) 
    { 
        for(i=0;i<m;i++)                 //查找  
        { 
            scanf("%s",s); 
            if(search(root,s)==1) 
                printf("YES\n"); 
            else
                printf("NO\n"); 
        } 
        printf("\n");    
    } 
    del(root);                         //释放空间很重要  
    return 0; 
}
```



https://blog.csdn.net/myjoying/article/details/7960534

https://blog.csdn.net/myjoying/article/details/7962177



##### Trie树

 在计算机科学中中，trie，又称前缀树，字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie树的应用包括：

    （1） 存储字典；
    （2）  应用在最大匹配算法，例如拼写检查，断词等；
    （3） 搜索引擎中的词频统计；
    （4） 树中分支的先序遍历结果就是字典序的；
Trie图



最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是**将给定序列中零个或多个元素去掉之后得到的结果**。什么是子串呢？给定串中任意个**连续的字符**组成的子序列称为该串的子串。

https://blog.csdn.net/hrn1216/article/details/51534607

https://www.cnblogs.com/fanguangdexiaoyuer/p/11281179.html



## 算法题

leetcode力扣 https://leetcode-cn.com/

牛客网https://www.nowcoder.com/

微信公众号：小浩算法、算法与数据结构、程序员面试、帅地玩编程





数组类（原位操作）



链表类

https://mp.weixin.qq.com/s/gchs1UI5XHgVP0_MtNSF9Q

博弈论



动态规划



滑动窗口



二叉树



### 摩尔投票法——俄罗斯方块消除法-动态规划

找出数组中出现次数大于n/m的元素

分析：在任何数组中，出现次数大于该数组长度n/m的值**只能有m-1个**（极限时为m个）

初始化m个容器（-1，计数为0）；遍历数组，当有空的容器时，记录该元素数值，计数加一；当没有空容器时，所有的容器计数同时减一；出现空容器时，原容器中的元素数值清空（-1），可记录其他元素数值。

```c
#include<stdio.h>
typedef struct Container_t
{
    int elem;
    int count;
} Container;

int majorityElement(int nums[], int len, int k)
{
    Container con[3]={{-1,0},{-1,0},{-1,0}};
    
    int flag= 0;
    
    for(int i=0; i<len; i++)
    {
        int exist=0;
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == nums[i])
            {
                con[j].count++;
                exist=1;
                break;
            } 
        }

        if(exist == 1)
            continue;
        
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == -1)
            {
                con[j].elem = nums[i];
                con[j].count++;
                break;
            }
        }
        
        int flag = 1;//do sub
        for(int j=0; j<k; j++)
        {
            if(con[j].elem == -1)
            {
                flag = 0;
                break;
            } 
        }
        
        if(flag == 1)
        {
            for(int j=0; j<k; j++)
            {
                con[j].count--;
                if(con[j].count == 0)
                {
                    con[j].elem = -1;
                }
            }
        }
    }
    
    for(int j=0; j<k; j++)
    {
        if(con[j].elem != -1)
        { 
            // check if there is a majority
            int counter = 0;
            for(int i=0; i<len; i++)
            {
                if (nums[i] == con[j].elem) counter++;
            }
            
            if (counter > (len + 1) / k)
                printf("the major is %d\n",con[j].elem);
        }  
    }
    return 0; 
}

int main(int argc, char* argv[])
{
    int* out = NULL;
    int num[] = { 7,3,3,7,4,5,4,7,3,4,3,4,7,3,4 };
    //int num[] ={4,3,3,9,4,2,4,4,3,4,9,2};
    
    int len = sizeof(num)/sizeof(int);
    
    printf("len = %d\n", len);
    
    majorityElement(num, len, 3);

	return 0;
}

```



小球碰撞与圆周率的关系

https://www.zhihu.com/tardis/landing/360/ans/577232436?query=%E4%B8%96%E7%BA%AA%E9%9A%BE%E9%A2%98%E7%90%83%E4%B8%8E%E5%A2%99%E7%9A%84%E6%8E%A5%E8%A7%A6%E6%AC%A1%E6%95%B0%E6%98%AF%E5%9C%86%E5%91%A8%E7%8E%87&mid=052f3b5b63bfa021f1bfabaccd052fef&guid=8B86173C022D2E8E6CCD8F010AE788E4.1574503853295

http://www.360doc.com/content/19/0206/00/32901809_813272203.shtml



李永乐老师视频



## C语言：函数返回字符串

1、 将字符串指针作为函数参数传入，并返回该指针。

典型的strcpy()函数应该就是采用的这种方法，第一个参数为指向目的字符串的指针,返回值也为这个指针。

内存空间在主函数中分配与释放

```c
char* strcpy(char* des,const char* source)
{
 char* r=des;
  assert((des != NULL) && (source != NULL));
　while((*r++ = *source++)!='\0');
　return des;
}
```

2、 使用malloc函数动态分配内存，注意在主调函数中释放。（堆区内存，需手动释放回收）

内存空间在子函数中分配，在主函数中释放

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//方法一 直接返回指针
char * retstring()
{
    char * name;
    name = (char *)malloc(10); 
    strcpy(name,"张汉青");
    return name;
}
//方法二 使用双重指针
int retstring2(char **ptr)
{
    *ptr = (char *)malloc(10); 
    strcpy(*ptr,"张汉青2");
    
    return 0;
}

int main()
{
    char * name2 = NULL;
    name2 = retstring();
    printf("%s\n",name2);
    //记住一定要用free释放，否则会造成内存泄露
    free(name2);
    name2 = NULL;
    
    retstring2(&name2);
    printf("%s\n",name2);
    //记住一定要用free释放，否则会造成内存泄露
    free(name2);
    name2 = NULL;
    return 0;
}
```

3、 返回一个静态局部变量。（不推荐）

这种方法有一个问题： 由于采用了静态局部变量（位于静态区，程序结束时由系统进行释放），这就导致，如果多次调用这个函数，**下一次调用会将上一次调用的结果覆盖掉。**

C语言中的库函数，tmpnam()函数、getenv()函数等应该都是采用的这种方法，这也就是为什么，使用这样的函数的时候应该立即将返回结果拷贝一份的原因。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char * retstring();
int main()
{
    char * name2;
    name2 = retstring();
    printf("%s\n",name2);
    return 0;
}

char * retstring()
{
    static char name[10];
    strcpy(name,"张汉青");
    return name;
}
```

4、 使用全局变量。（不推荐）

```c
char   g_s[100]; 
char*   fun() 
{ 
        strcpy(g_s,   "abc "); 
        return   g_s; 
} 
```



### snprintf

自从snprintf代替了sprintf，相信大家对snprintf的使用都不会少，函数定义如下：

**int snprintf(char*str, size_t size,constchar*format, ...);**

函数说明:

最多从源串中拷贝**（size－1）**个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为size的话，将不会溢出。

函数返回值:

若成功则返回**欲写入**的字符串长度（非实际写入），若出错则返回负值。

### strncpy



## C/C++刁钻问题各个击破之细说sizeof

Sizeof的作用非常简单：求对象或者类型的大小。然而sizeof又非常复杂，它涉及到很多特殊情况，本篇把这些情况分门别类，总结出了sizeof的10个特性：

(0)sizeof是运算符，不是函数；

(1)sizeof不能求得void类型的长度；

(2)sizeof能求得void类型的指针的长度；

(3)sizeof能求得静态分配内存的数组的长度!

**(4)sizeof不能求得动态分配的内存的大小!**

(5)sizeof不能对不完整的数组求长度；

(6)当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！

(7)sizeof可以对函数调用求大小，并且求得的大小等于返回类型的大小，但是不执行函数体！

(8)sizeof求得的结构体(及其对象)的大小并不等于各个数据成员对象的大小之和！

(9)sizeof不能用于求结构体的位域成员的大小，但是可以求得包含位域成员的结构体的大小！