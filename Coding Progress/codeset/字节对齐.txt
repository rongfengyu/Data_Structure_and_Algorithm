
字节对齐

自然对齐
对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004，那它就是自然对齐的。


需要字节对齐的根本原因在于CPU访问数据的效率问题。如果变量在自然对齐位置上，则只要一次就可以取出数据。
一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误segment error。

 对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：
　　
　　数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 
　　联合 ：按其包含的长度最大的数据类型对齐。 
　　结构体： 结构体中每个数据类型都要对齐。

　　比如有如下一个结构体：　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　};
　　struct stu my_stu;　　
　　由于在x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15.

__attribute__选项　　
　　我们可以按照自己设定的对齐大小来编译程序，GNU使用__attribute__选项来设置，比如我们想让刚才的结构按一字节对齐，我们可以这样定义结构体
　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　}__attribute__ ((aligned (1))); 
　　
　　struct stu my_stu;
　　 
　　
　　则sizeof(my_stu)可以得到大小为15。
　　
　　上面的定义等同于
　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　}__attribute__ ((packed)); 
　　struct stu my_stu;　　
　　__attribute__((packed))得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐.

什么时候需要设置对齐
　　
　　 在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.


1. 什么是字节对齐？

在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.

2. 字节对齐有什么作用？

字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。

对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。

3. 更改C编译器的缺省字节对齐方式

在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：
・ 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。
・ 使用伪指令#pragma pack ()，取消自定义字节对齐方式。

另外，还有如下的一种方式：
・ __attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
・ __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐



什么是字节对齐,为什么要对齐?
TragicJun 发表于 2006-9-18 9:41:00 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
      对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。


针对字节对齐,我们在编程中如何考虑?
        如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0,然后各个变量按照上面的原则进行排列即可,基本的原则就是把结构中的变量按照类型大小从小到大声明,尽量减少中间的填补空间.还有一种就是为了以空间换取时间的效率,我们显示的进行填补空间进行对齐,比如:有一种使用空间换时间做法是显式的插入reserved成员：
             struct A{
               char a;
               char reserved[3];//使用空间换时间
               int b;
}

reserved成员对我们的程序没有什么意义,它只是起到填补空间以达到字节对齐的目的,当然即使不加这个成员通常编译器也会给我们自动填补对齐,我们自己加上它只是起到显式的提醒作用.



如果出现对齐或者赋值问题首先查看
1. 编译器的big little端设置
2. 看这种体系本身是否支持非对齐访问
3. 如果支持看设置了对齐与否,如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作







#include <stdio.h>

struct stu
{
	char sex;//1，填充3字节
	int age;//4
	char name[10];//10，填充2字节
};//默认gcc 4字节对齐

struct stu2
{
	int age;
	char sex;
	char name[10];//自动填充1字节
};//默认gcc 4字节对齐

//从前两者看出，较长的类型写在前面有助于节省空间

//__attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。
//如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
//
//__attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。最小单位，可能为char 1字节

struct stu3
{
	int age;
	char name[10];
	char sex;
}__attribute__ ((packed));//按最小的类型进行对齐，此处char 1字节对齐

struct stu4
{
	char sex;
	int age;
	char name[10];
}__attribute__ ((aligned (1)));//按1字节对齐，但是最大的int为4字节，因此按四字节对齐，同stu

struct stu5
{
	int age;
	char sex;
	char name[10];
}__attribute__ ((aligned (1)));//按1字节对齐，但是最大的int为4字节，因此按四字节对齐，同stu2

struct stu6
{
	int age;
	char sex;
	char name[10];
}__attribute__ ((aligned (2)));

int main () {
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu));//20
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu2));//16
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu3));//15
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu4));//20
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu5));//16
	printf("hello https://tool.lu/  %d\n", sizeof(struct stu6));//16
	return 0;
}