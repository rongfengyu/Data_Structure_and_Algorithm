Writing Solid Code


1、重视程序编译过程中的输出信息：保证自己写的代码在编译时不输出任何warning；使用编译软件输出与splint警告来增强代码

2、增强函数原型能力，原型中使用精确的类型，副作用：常常需要进行参数的显示类型转换，以消除类型不匹配的问题

3、任何代码改动都要做好单元测试，不要高估自己编写正确代码的能力

4、DEBUG软件版本中使用断言（assert宏）进行调试，它是可以安全使用且无害（不增加程序运行负担与引起内存代码的兑换）的检测手段

assert宏常用来作入口函数参数的判空操作，它不能移动内存的内容，不能调用其它的函数或者引起了其它不期望的副作用。

5、删除程序中使用的无定义特性：如memcpy函数中的两个指针参数是否可能存在重叠操作的区域？几乎没有人考虑过吧！可以使用assert来检查
void memcpy(void* pvTo, void* pvFrom, size_t size)
{
    void* pbTo = (byte*)pvTo;
    void* pbFrom = (byte*)pvFrom;

    ASSERT(pvTo != NULL && pvFrom != NULL);//参数合法性

    /* 内存块重叠吗？如果重叠，就使用memmove */
    ASSERT(pbTo>=pbFrom+size || pbFrom>=pbTo+size);//重叠区域检查

    while(size-->0)
        *pbTo++ == *pbFrom++;

    return(pvTo);
}

6、为了使程序员能够理解断言的意图，要给不够清楚的断言加上注解

7、断言不是用来检查错误的。当程序员刚开始使用断言时， 有时会错误地利用断言去检查真正地错误， 而不去检查非法的况。

如malloc等函数的返回值检查
char* strdup(char* str）
{
    char* strNew;
    ASSERT(str != NULL);//正确的断言，检查参数合法性

    strNew = (char*)malloc(strlen(str)+1);
    ASSERT(strNew != NULL);//不正确的断言，断言中的情况在正常情况下也可能出现的

    strcpy(strNew, str);
    
    return(strNew);
}

8、memset在填充内存时，换用字节长度较大的数据类型进行填充，可以加快填充速度，条件size>sizeThreshold


9、尽量不要再代码里写入魔数，尽量写成宏，避免程序修改带来的调试负担与风险。有名的常量不仅可以使代码更可读，而且使代码更可移植

10、表格驱动算法：反汇编程序，用一个含有屏蔽码、 指令特征和译码函数的表格对每条指令进行检查。 查表程序循环检查指令，如果匹配上某条指令，就调用相应的译码程序译出该指令的register和Mode域

表格驱动法，需要对入口之间进行必要的检查，包含关系、冲突关系等

11、对于程序必须做好的关键部分，需要使用不同的算法进行结果确认。


12、瓶颈子程序是加入断言的绝佳之处

对于内存管理程序。程序员可能犯的错误是：
1）分配一个内存块并使用其中未经初始化的内容；
2）释放一个内存块但继续引用其中的内容；
3）调用realloc对一个内存块进行扩展， 因此原来的内容发生了存储位置的变化， 但程序引用的仍是原来存储位置的内容；
4）分配一个内存块后即“ 失去” 了它，因为没有保存指向所分配内存块的指针；
5）读写操作越过了所分配内存块的边界；
6）没有对错误情况进行检查

13、是否应该对malloc分配的内存填零，这样可能会隐藏一些错误，比如随机性的错误。可以对malloc分配的内存填充特殊的奇数。


14、对代码进行逐条跟踪时密切地注视数据流，就会帮助你查出下面这么多的错误：
    上溢和下溢错误；
    数据转换错误；
    差1错误；
    NULL指针错误；
    使用废料内存单元错误（0xA3类错误）；
    用 = 代替 == 的赋值错误；
    运算优先级错误；
    逻辑错误

15、不要使用容易引起混淆的双重意义的返回值，如getchar（）函数

16、停下来思考所做的设计，检查输入和输出的各种可能组合，寻找可能引起问题的副作用，如getchar、malloc、realloc等调用返回失败的情况

17、不需要一个面面俱到的函数中去实现一个完整子系统去完成的事情，函数功能只需要单一就好
要编写多种功能集于一身的函数为了对参数进行更强的确认，要编写功能单一的函数

18、一开始就要为函数的输入选择严格的定义，并最大限度地利用断言。不要模棱两可，要明确地定义函数的参数

19、如果发现自己在设计函数时要返回一个错误代码， 那么要先停下来问自己： 是否还有其它的设计方法可以不用返回该错误情况


20、每种特殊情况只处理一次，不要到处对一种情况进行反复判断

21、不要过高地估计代价：关心局部效率是不值得的。如果你很注重效率的话，请集中于全局效率和算法的效率上，这样你才会看到努力的效果。

22、使用括号避免运算符优先级可能带入的问题

23、通过最大限度地增加公共代码的数量来使代码差异减到最少。降低代码维护的难度

24、只引用属于你自己的存储空间

25、已经释放的存储空间或指针不能再使用！存储管理程序可能已将这块释放的空间连到空闲链上了，或已将它用于别的私有信息了，如
for(pwnd = pwndRoot->pwndChild;pwnd != NULL;pwnd = pwnd->pwndSibling)
    FreeWindowTree(pwnd)

26、指向输出的指针不是指向工作空间缓冲区的指针

27、不要利用静态（或全局）量存储区传递数据，避免造成不可重入问题。在设计函数过程中，当需要向缓冲区传递数据时，安全的方法是让调用者分配一个局部（非静态）的缓冲区。

28、紧凑的C代码并不能保证得到高效的机器代码。代码精炼行数少，不一定意味着代码执行效率就高

29、为一般水平的程序员编写代码。程序员有两类读者：使用代码的用户和必须对代码进行更新的程序维护人员。程序维护人员一般都是该项目的新手而不是专家。
static char strDayNames[]=” SunMonTueWedThuFriSat” ;
…
strncpy(strDay,&strdayNames[day*3],3);

30、一般来说，有经验的程序员编写出代码，新手维护代码。能用普通程度语言表达清楚时，就应该避免使用困难的或神秘的C。编写直观的代码才是真正的聪明人。


