定义
struct tag {member_list} var_list;

struct tag A,B,C;


别名
typedef struct {int A;} TAG;

TAG AA,BB;

注意结构体成员访问优先级

直接访问.  优先级高于 简接访问->


（comp.sa）[4]）.c  等价于 comp.sa[4].c


结构体的自引用――结构体内部引用时使用指针

结构体的互相引用――使用不完整声明（或使用别名typedef的技巧）

============
结构体第一个成员地址强制转换
struct xx
{ 
int a;
char b;
}xx_t;

int *pi;

不合适的做法：pi = (int *)px;
合适的做法：pi = &px->a;
=============

对于数组b[10]
*（b+1）== b[1]


存储分配：
1.所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的的位置

2.结构体成员在排列时，对边界要求最严格的成员首先出现，对边界要求最弱的成员最后出现

例外：为了程序的可维护性和可读性

sizeof可得出结构体的整体长度（包括边界对齐的）

offsetof确定结构体成员位置，stddef.h
offsetof（ type，member ）

向函数传递・结构体指针・而不是传递一个・结构・本身


位段的使用需谨慎，限制较多，移植性较差
任何可以使用位段实现的任务都可以使用移位和屏蔽来实现

在一个成员长度不同的联合体里，分配给联合的内存数量取决于它的最长成员的长度。

联合中存储指向不同成员的指针而不是直接存储成员本身，移位成员长度若相差悬殊，内存浪费较大

对每个从malloc返回的指针都要进行检查，确保它并非NULL

void *malloc( size_t size );
注意：参数为需要分配的内存字节数
一般地， int *pi= malloc( 25 * sizeof( int ) );

传递给free的指针必须是一个从malloc、calloc、realloc函数返回的指针
不允许释放一块内存的一部分
不要访问已经被free释放的内存（内存指针多次拷贝、散落到各处），指针释放后置空，每次使用时判断是否为空！

sizeof与Strlen的区别与联系
    sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
    它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
    strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
    它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。

char* ss = "0123456789"; 
sizeof(ss) 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是 

长整型的，所以是4 
sizeof(*ss) 结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位'0' 所占的内存空间，是char类 

型的，占了 1 位 

strlen(ss)= 10 >>>> 如果要获得这个字符串的长度，则一定要使用 strlen

函数指针：回调函数&转移表（switch）

预处理器：删除注释、插入被#include指令包含的文件的内容、定义和替换由#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译

代码编译之前对其进行一些文本性质的操作
宏与类型无关
命令行定义宏――（-D选项）同一份源文件编译出不同版本的程序
