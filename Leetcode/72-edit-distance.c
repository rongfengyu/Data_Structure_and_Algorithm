/*
72. 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')


注解：
二维DP类型题目

三个编辑动作均影响状态转移表达式

编辑距离又叫莱文斯坦距离（Levenshtein distance），用于评估两个字符串的差异程度，在拼写检查、文本对比（diff）等场景中都有应用。编辑距离问题的实际意义使得它非常受面试官青睐。
编辑距离问题是 LeetCode Hard 题目，很多同学做这道题的时候会觉得很难，总是找不到思路。这道题的难点主要有两个：
第一，如何在拿到题目的时候想到可以用动态规划来解。这一般需要你做过二维动态规划的经典例题，然后联想到本题的思路。
第二，如何从题目描述中拆解出动态规划的具体思路。这需要你有一些拆解动态规划题目的技巧。

动态规划题目的解题步骤我们都知道，要先定义子问题，再写出子问题的递推关系。

解题四步骤
步骤一：定义子问题
上文我们已经讨论了两个字符串的动态规划问题的子问题套路。和最长公共子序列问题一样，我们可以定义子问题  f(i, j)为「s[0..i) 和 t[0..j) 的编辑距离」。那么，这是一道二维动态规划问题。

步骤二：写出子问题的递推关系
子问题的递推关系就和三种编辑操作相对应。对于 s[0..i) 和 t[0..j) 的编辑距离，我们有三种方案：
删除 s[i-1]，然后计算 s[0..i-1) 和 t[0..j) 的编辑距离
插入 t[j-1]，然后计算 s[0..i) 和 t[0..j-1) 的编辑距离
将 s[i-1] 替换为 t[j-1]，然后计算 s[0..i-1) 和 t[0..j-1) 的编辑距离
对于这三种方案，我们需要找出其中操作最少的方案。

如果 s[i-1] 和 t[j-1] 本来就相等的话，是不需要这一步替换的，编辑操作可以减少一次。那么，我们要比较 s[0..i) 和 t[0..j) 的最后一个字符，即 s[i-1] 和 t[j-1]。这可能会有两种情况：
第一种情况：如果 s[i-1] != t[j-1]，我们可以做「插入」、「删除」或者「替换」操作。
第二种情况：如果 s[i-1] == t[j-1]，那么这最后一个字符不需要进行任何编辑操作，我们可以去掉最后一个字符，然后计算 s[0..i-1) 和 t[0..j-1) 的编辑距离。

用公式写出来的话，就是：

            f(i-1,j-1),if s(i-1) = t(j-1)     
f(i,j) =           { f(i-1,j)   }                       //删除操作
            1 + min{ f(i,j-1)   },if s(i-1) != t(j-1)   //插入操作
				   { f(i-1,j-1) }                       //替换操作

递推关系的 base case。
当 i=0 时，s[0..i) 为空，还剩 t[0..j) 的 j 个字符，我们需要做 j 次插入操作，因此 f(0,j)=j。
当 j=0 时，类似地，有 f(i,0)=i。

步骤三：确定 DP 数组的计算顺序
对于二维动态规划问题，我们需要定义二维的 DP 数组，其中 dp[i][j] 对应子问题 f(i,j)，即 s[0..i) 和 t[0..j) 的编辑距离。
设 s 的长度为 m，t 的长度为 n，则 i、j 的取值范围分别为：0<=i<=m,0<=j<=n。DP 数组是一个 m*n 的矩形。
为了确定 DP 数组的计算顺序，我们需要知道子问题的依赖方向。观察子问题的递推关系，f(i,j) 依赖于 f(i-1,j)、f(i,j-1) 和 f(i-1,j-1)，
DP 数组的计算顺序同样是从左到右、从上到下。我们应该以这样的顺序遍历 DP 数组：
for (int i = 0; i <= m; i++) {
    for (int j = 0; j <= n; j++) {
        // 计算 dp[i][j] ...
    }
}

这个算法的时间、空间复杂度均为 O(mn)，其中 m、n 分别表示 s、t 的长度。
*/

public int minDistance(String s, String t) {
    // 子问题：
    // f(i, j) = s[0..i) 和 t[0..j) 的编辑距离

    // f(0, j) = j
    // f(i, 0) = i
    // f(i, j) = f(i-1, j-1), if s[i-1] == t[j-1]
    //           min: f(i-1, j) + 1
    //                f(i, j-1) + 1
    //                f(i-1, j-1) + 1, if s[i-1] != t[j-1]

    int m = s.length();
    int n = t.length();
    int[][] dp = new int[m+1][n+1];
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else {
                if (s.charAt(i-1) == t.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = 1 + min3(
                        dp[i-1][j],  // 删除操作
                        dp[i][j-1],  // 插入操作
                        dp[i-1][j-1] // 替换操作
                    );
                }
            }
        }
    }
    return dp[m][n];
}

private int min3(int x, int y, int z) {
    return Math.min(x, Math.min(y, z));
}