/*
739. 每日温度
根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。


题目解析


1、常规思路：从后向前遍历数组，使用两层循环，最坏的情况是时间复杂度O(N^2)


2、使用栈的思路：（递减栈）
这个题目的标签是 栈 ，我们考虑一下怎么借助 栈 来解决。

不过这个栈有点特殊，它是 递减栈 ：栈里只有递减元素。

具体操作如下：

遍历整个数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是 递减栈 ，所以需要取出栈顶元素，

由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。

继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来。

由于传入的参数是数组，入栈的可以是数组索引，而不是该数元素！

*/


//五分钟学算法
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n, 0);
        stack<int> st;
        for (int i = 0; i < temperatures.size(); ++i) {
            while (!st.empty() && temperatures[i] > temperatures[st.top()])//入栈的是数组索引，出栈使用索引取元素的值
           {
                auto t = st.top(); st.pop();
                res[t] = i - t;
            }
            st.push(i);
        }
        return res;
    }
};

//该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。


//利用堆栈，还可以解决如下常见问题：
//求解算术表达式的结果（LeetCode 224、227、772、770)
//求解直方图里最大的矩形区域（LeetCode 84）
