/*
11. 盛最多水的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

  X         X
  X         X   X
  X X       X   X
  X X   X   X   X
  X X   X X X   X
  X X   X X X X X
  X X X X X X X X
X X X X X X X X X

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49



注解：
方法一：暴力双重循环，时间复杂度为O(N^2)


方法二：双指针法，时间复杂度为O(N)，空间复杂度为O(1)，属于贪心算法

设立两个指针，一个从头一个从尾，相向而行遍历数组，每次舍弃较短边
（1）计算面积最大值的初值，该初值以数组中的第一个元素和最后一个元素构成两边。

（2）设置首尾两个指针，首指针i指向数组中的第一个元素，尾指针j指向数组中的最后一个元素。

（3）当首指针i小于尾指针j时，一直循环计算其面积。若计算所得的当前面积大于（1）步骤中所计算得的面积最大值，则更新最大值。每一次循环都舍弃索引i和索引j中较短的那一条边。

双指针法的正确性证明：

WXID 是不是很酷 的文章：《优雅地证明 盛水容器问题》

根据排列组合的知识，如果总共有 n 块木板可以选择的话，我们可以暴力枚举任意两块木板的组合，检查他们组成的容器面积，一共需要检查 n * (n - 1) / 2 对木板的组合。

而这个算法为什么没有漏掉一个可能的更大面积的容器？

我们来看初始的时候，left 指向 a[0]，right 指向 a[n-1]。我们假设 a[0] 是小于 a[n-1] 的，即 a[0] < a[n-1]。那么下一步，根据我们的算法，就是 left ++，即 left 下一步指向了 a[1]。
这意味着什么？这就意味着，使用 a[0] 和 a[n-2]；使用 a[0] 和 a[n-3]；使用 a[0] 和 a[n-4]；.... ；使用 a[0] 和 a[1]，这些木板的组合，我们都直接跳过去了，不去计算了。
换句话说，因为我们直接 left ++ 了，所以所有的以 a[0] 为左边木板的其他组合，都不看了。
为什么可以这样？
还记得我们的假设吗？a[0] 是小于 a[n-1] 的。所以，此时，整个容器的高度，是由 a[0] 决定的。因为，如果右边板的高度大于 a[0]，我们取短板，容器的高度还是 a[0]；如果右边的高度小于 a[0]，那么容器的高度比 a[0] 还要小。
而对于其他的以 a[0] 为左边木板的组合：a[0] 和 a[1]，a[0] 和 a[2]，a[0] 和 a[3]，...，a[0] 和 a[n-2]，底的长度都比 a[0] 和 a[n-1] 更小。而高度又不会超过 a[0]，所以，面积一定是更小的，我们就可以直接排除掉！
那么这个过程，我们一下子排除了多少组组合呢？答案是，左边是 a[0]，右边是 a[1] ... a[n-2]，一共 n-2 组组合，直接被我们扔掉了。
当然，如果我们假设 a[0] > a[n-1]，这个逻辑同样成立，只不过我们扔掉的组合，右边固定为 a[n-1]，左边是 a[1] 到 a[n-2]，还是 n-2 个组合。
……
……
我们一共扔掉了 (n-1)*(n-2)/2 这么多组合，只计算了 n-1 这么多组合。
把他们加起来，答案是 n * (n - 1) / 2！

大家回忆一下，这个数字正好就是 n 块木板，抽出两块，组成容器的所有可能方案！
C(n, 2) = n * (n - 1) / 2！


值得一提的是，虽然我们说这个问题是双指针的问题，但其实，在算法设计上，我们使用了贪心的思想。即每次把最短木板对应的所有其余组合都扔掉了。
而对于贪心算法来说，最大的特点就是：通常代码都会比较简单，但要想证明贪心的正确性，会比较费劲。这个问题就是一个很好的例子。

*/

#include <stdio.h>

#define min(a,b) ((a)>(b)?(b):(a))
#define max(a,b) ((a)<(b)?(b):(a))

int maxArea(int* height, int heightSize){
	if(heightSize <= 1) return -1;

	int i = 0;
	int j = heightSize - 1;
	int area = (heightSize - 1) * min(height[i], height[j]);
	
	while(i < j) {
		area = max(area, (j - i) * min(height[i], height[j]));
		if(height[i] < height[j]) {
			i++;
		}else {
			j--;
		}
	}
	return area;

}

int main(int argc, char* argv[])
{
    int nums[] = {1,8,6,2,5,4,8,3,7};
    int size = sizeof(nums)/sizeof(int);
	
    int ret  = 0;
	ret = maxArea(nums, size);
	printf("ret = %d\n", ret);//49

    return 0;
}
